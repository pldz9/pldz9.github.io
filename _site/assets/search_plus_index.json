{"/ros2_car/2023-06-02-2_1_%E9%80%9A%E8%BF%87Turtlebot3%E6%A1%88%E4%BE%8B%E4%BA%86%E8%A7%A3NAVI2.html": {
    "title": "2 通过 Turtlebot3 案例了解 NAVI2",
    "keywords": "ROS2_CAR",
    "url": "/ros2_car/2023-06-02-2_1_%E9%80%9A%E8%BF%87Turtlebot3%E6%A1%88%E4%BE%8B%E4%BA%86%E8%A7%A3NAVI2.html",
    "body": "1.1 Ubuntu20.04 安装 ROS2(Foxy) 参考内容： 官网给出的教程 换源，输入sudo gedit /etc/apt/sources.list这里选择的是中科大的源，如果你是在 Ubuntu 内部选择的软件源，笔者遇到过安装 ROS2 时候提示没有 depends 的情况，于是这里手动换源，将文件源更改如下： deb https://mirrors.ustc.edu.cn/ubuntu/ focal main restricted universe multiverse deb-src https://mirrors.ustc.edu.cn/ubuntu/ focal main restricted universe multiverse deb https://mirrors.ustc.edu.cn/ubuntu/ focal-updates main restricted universe multiverse deb-src https://mirrors.ustc.edu.cn/ubuntu/ focal-updates main restricted universe multiverse deb https://mirrors.ustc.edu.cn/ubuntu/ focal-backports main restricted universe multiverse deb-src https://mirrors.ustc.edu.cn/ubuntu/ focal-backports main restricted universe multiverse deb https://mirrors.ustc.edu.cn/ubuntu/ focal-security main restricted universe multiverse deb-src https://mirrors.ustc.edu.cn/ubuntu/ focal-security main restricted universe multiverse deb https://mirrors.ustc.edu.cn/ubuntu/ focal-proposed main restricted universe multiverse deb-src https://mirrors.ustc.edu.cn/ubuntu/ focal-proposed main restricted universe multiverse 更新源和软件：sudo apt-get update &amp;&amp; sudo apt-get upgrade 配置语言，需要支撑UTF-8： pldz@pldz-pc:~$ locale LANG=en_US.UTF-8 LANGUAGE= LC_CTYPE=\"en_US.UTF-8\" LC_NUMERIC=zh_CN.UTF-8 LC_TIME=zh_CN.UTF-8 LC_COLLATE=\"en_US.UTF-8\" LC_MONETARY=zh_CN.UTF-8 LC_MESSAGES=\"en_US.UTF-8\" LC_PAPER=zh_CN.UTF-8 LC_NAME=zh_CN.UTF-8 LC_ADDRESS=zh_CN.UTF-8 LC_TELEPHONE=zh_CN.UTF-8 LC_MEASUREMENT=zh_CN.UTF-8 LC_IDENTIFICATION=zh_CN.UTF-8 LC_ALL= pldz@pldz-pc:~$ 获取 GPG 秘钥：sudo apt update &amp;&amp; sudo apt install curl -y然后sudo curl -sSL https://raw.githubusercontent.com/ros/rosdistro/master/ros.key -o /usr/share/keyrings/ros-archive-keyring.gpg，此时如果提示无法访问到网站，则添加 host： 访问 https://tool.lu/ip/ 并输入域名 raw.githubusercontent.com，查询 ip 地址，这里查询到的是 185.199.108.133 修改 sudo gedit /etc/hosts文件,并手动添加 DNS 解析： 添加 ROS2 的仓库：echo \"deb [arch=$(dpkg --print-architecture) signed-by=/usr/share/keyrings/ros-archive-keyring.gpg] http://packages.ros.org/ros2/ubuntu $(. /etc/os-release &amp;&amp; echo $UBUNTU_CODENAME) main\" | sudo tee /etc/apt/sources.list.d/ros2.list &gt; /dev/null 更新源和软件：sudo apt-get update &amp;&amp; sudo apt-get upgrade 下载 ROS2 Foxy：sudo apt install ros-foxy-desktop python3-argcomplete 下载完成后下载 ROS2 开发工具：sudo apt install ros-dev-tools 将 ROS2 添加到环境变量：sudo echo \"source /opt/ros/foxy/setup.bash\" &gt;&gt; ~/.bashrc 激活环境变量验证安装：source ~/.bashrc，然后输入ros2 run turtlesim turtlesim_node如果能够看到小乌龟则代表成功 1.2 运行 ROS2 NAVI 例子 1.2.1 安装仿真的依赖项和软件 参考内容 [ROS2 基础] Navigation2 导航系统 《动手学 ROS2》10.10 通过 Nav2API 进行导航 ROS2 与 Navigation2 入门教程-构建和安装 Nav2 下载功能包：需要的功能包包括turtlebot3的模型和cartographer,以及rviz2和gazebo环境，其中的gazebo主要用于模拟真实的物理环境，rviz2是ROS2通讯的可视化工具 sudo apt install ros-foxy-turtlebot3* sudo apt install ros-foxy-cartographer # 如果没有gazebo和rviz2的需要再次安装这两个软件 sudo apt install ros-foxy-rviz2 sudo apt install ros-foxy-gazebo* 在运行仿真环境的时候，有时候会卡住在 gazebo 打开的界面，gazebo 初始化打开时候是会连接网络下载模型库,否则可能会出现打开了环境，但是机器人一直在缩小的情况 到 gazebo 的 github 官方网页: osrf/gazebo_models，下载全部模型为 zip 文件 解压 zip 文件夹并重命名为models，然后拷贝到~/.gazebo的目录下 1.2.2 建立导航的地图(Mapping) 启动导航的物理仿真环境：创建一个启动 gazebo 物理仿真环境的脚本，比方说这里的naviWorld.sh（赋予可执行权限） # naviWorld.sh export TURTLEBOT3_MODEL=burger ros2 launch turtlebot3_gazebo turtlebot3_world.launch.py 第一次启动，可能会出现一直在等待的状态，并且提示Spawn service failed. Exiting.， 错误的解决办法可以参考 1.3.1 的内容，杀死 gazebo 再次启动即可 启动建图指令：创建一个RVIZ2环境用于显示小车的状态，并建立起导航的地图，例如这里的mapping.sh（赋予可执行权限）： # mapping.sh export TURTLEBOT3_MODEL=burger ros2 launch turtlebot3_cartographer cartographer.launch.py use_sim_time:=True 启动成功之后，会出现 rviz2 的界面： 控制机器人移动生成地图文件，输入命令：ros2 run turtlebot3_teleop teleop_keyboard启动键盘控制小车运动的节点，在此之前可以指定小车的类型：export TURTLEBOT3_MODEL=burger，例如下面的 telep.sh # telep.sh export TURTLEBOT3_MODEL=burger ros2 run turtlebot3_teleop teleop_keyboard 完成建图，生成导航的地图文件和信息，通过teleop_keyboard打开的终端控制机器人移动，等待图片大部分被扫描成功后，输入命令行调用map_server存储地图，其中的地图名称为 test，之后会生成以该名字命名的.pgm/yaml等文件：ros2 run nav2_map_server map_saver_cli -f testMap pldz@pldz-pc:/mnt/hgfs/VMware/ROS2_NAVI/1_Chapter/code$ ros2 run nav2_map_server map_saver_cli -f testMap [INFO] [1684547384.636100069] [map_saver]: map_saver lifecycle node launched. Waiting on external lifecycle transitions to activate See https://design.ros2.org/articles/node_lifecycle.html for more information. [INFO] [1684547384.636296866] [map_saver]: Creating [INFO] [1684547384.636480318] [map_saver]: Configuring [INFO] [1684547384.638094058] [map_saver]: Saving map from 'map' topic to 'testMap' file [WARN] [1684547384.638189556] [map_saver]: Free threshold unspecified. Setting it to default value: 0.250000 [WARN] [1684547384.638247635] [map_saver]: Occupied threshold unspecified. Setting it to default value: 0.650000 [WARN] [map_io]: Image format unspecified. Setting it to: pgm [INFO] [map_io]: Received a 125 X 119 map @ 0.05 m/pix [INFO] [map_io]: Writing map occupancy data to testMap.pgm [INFO] [map_io]: Writing map metadata to testMap.yaml [INFO] [map_io]: Map saved [INFO] [1684547384.984216612] [map_saver]: Map saved successfully [INFO] [1684547384.985701952] [map_saver]: Destroying pldz@pldz-pc:/mnt/hgfs/VMware/ROS2_NAVI/1_Chapter/code$ ls mapping.sh naviWorld.sh simNavi2.sh telep.sh testMap.pgm testMap.yaml 1.2.3 使用地图文件进行导航 当有了地图文件之后，就可以根据地图文件，进行小车的导航仿真，这里启动turtlebot3的物理仿真环境，也就是建图时候的gazebo，实际上也就是之前的naviWorld.sh： export TURTLEBOT3_MODEL=burger ros2 launch turtlebot3_gazebo turtlebot3_world.launch.py 有了物理仿真环境之后，再加载地图进行导航的仿真，其中的map:后面的参数为之前的map_server生成的地图文件位置，创建导航的脚本simNavi2.sh，此时会提示Frame map does not exit.是因为没有给出起始的位置建立odom和map直接的计算: export TURTLEBOT3_MODEL=burger ros2 launch turtlebot3_navigation2 navigation2.launch.py use_sim_time:=true map:=testMap.yaml 给出起始点：在rviz2工具上拖动2D Pose Estimate，给出小车位置，完成坐标的变换： 1.2.4 可能出现的问题汇总（持续更新） 1.2.4.1 ROS2 gazebo：Spawn service failed. Exiting. 错误的提示如下： [spawn_entity.py-4] [INFO] [1684419460.753634677] [spawn_entity]: Loading entity XML from file /opt/ros/foxy/share/turtlebot3_gazebo/models/turtlebot3_burger/model.sdf [spawn_entity.py-4] [INFO] [1684419460.755174212] [spawn_entity]: Waiting for service /spawn_entity, timeout = 30 [spawn_entity.py-4] [INFO] [1684419460.755469679] [spawn_entity]: Waiting for service /spawn_entity [spawn_entity.py-4] [ERROR] [1684419490.844590431] [spawn_entity]: Service %s/spawn_entity unavailable. Was Gazebo started with GazeboRosFactory? [spawn_entity.py-4] [ERROR] [1684419490.844908061] [spawn_entity]: Spawn service failed. Exiting. [ERROR] [spawn_entity.py-4]: process has died [pid 8128, exit code 1, cmd '/opt/ros/foxy/lib/gazebo_ros/spawn_entity.py -entity burger -file /opt/ros/foxy/share/turtlebot3_gazebo/models/turtlebot3_burger/model.sdf -x -2.0 -y -0.5 -z 0.01 --ros-args']. 尝试解决办法： 杀死全部的gazebo server在命令行输入：lsof -i查看是否还有在运行的gzserver，记录程序的 PID 号，对输入kill -9 &lt;pid号&gt;杀死程序 再次输入脚本指令打开gazebo 1.2.4.2 [map_saver]: Failed to spin map subscription 错误的提示如下： pldz@pldz-pc:/mnt/hgfs/VMware/ROS2_NAVI/1_Chapter/code$ rerver map_saver_cli -os2 run nav2_map_server map_saver_cli -f testMap [INFO] [1684547337.249208762] [map_saver]: map_saver lifecycle node launched. Waiting on external lifecycle transitions to activate See https://design.ros2.org/articles/node_lifecycle.html for more information. [INFO] [1684547337.249693695] [map_saver]: Creating [INFO] [1684547337.250079483] [map_saver]: Configuring [INFO] [1684547337.256994454] [map_saver]: Saving map from 'map' topic to 'testMap' file [WARN] [1684547337.257098278] [map_saver]: Free threshold unspecified. Setting it to default value: 0.250000 [WARN] [1684547337.257179799] [map_saver]: Occupied threshold unspecified. Setting it to default value: 0.650000 [ERROR] [1684547339.261336746] [map_saver]: Failed to spin map subscription [INFO] [1684547339.262984556] [map_saver]: Destroying 尝试解决办法，造成的原因是因为map_server没有办法找到/map的话题来订阅，可能是之前你在打开RVIZ2或者其他内容时，没有启动完全，尝试退出终端，再次启动，其中之后输入ros2 topic list | grep map查看是否有/map的话题，有则可以再次输入保存地图文件的命令。"
  },"/ros2_car/2023-06-01-1_1_docker%E5%91%BD%E4%BB%A4%E7%86%9F%E6%82%89.html": {
    "title": "1 Docker 搭建 ROS2 嵌入式运行环境",
    "keywords": "ROS2_CAR",
    "url": "/ros2_car/2023-06-01-1_1_docker%E5%91%BD%E4%BB%A4%E7%86%9F%E6%82%89.html",
    "body": "1.1 安装 docker 1.2 docker 安装并配置 ubuntu20 拉取 docker 镜像：sudo docker pull ubuntu:20.04 启动镜像： docker run --rm -it --network=host ubuntu:20.04 docker run 是用于运行容器的 Docker 命令。 --rm 标志用于在容器停止后自动删除容器。这可以确保每次运行容器时都会清理掉容器，以避免产生无用的容器。 -it 是两个标志的结合。-i 标志表示保持标准输入(stdin)打开，使得你可以与容器进行交互。-t 标志表示为容器分配一个伪终端(pseudo-TTY)，以便你可以在命令行中与容器进行交互。 --network=host 标志用于将容器与主机共享网络命名空间。这意味着容器将与主机共享网络接口，可以访问主机上的网络资源。 ubuntu:20.04 是指定要运行的容器镜像。在这个例子中，使用的是基于 Ubuntu 20.04 的镜像 docker 内更新这样才能使用 apt-get 安装软件:apt-get update jeston@jeston-desktop:~$ sudo docker run --rm -it --network=host ubuntu:20.04 root@jeston-desktop:/# uname -a Linux jeston-desktop 4.9.253-tegra #1 SMP PREEMPT Sat Feb 19 08:59:22 PST 2022 aarch64 aarch64 aarch64 GNU/Linux root@jeston-desktop:/# apt-get update 安装基本软件：apt-get install vim net-tools iputils-ping lsof 学会保存 docker 的状态：保存对容器的修改 新开一个终端获取 docker 的 id: sudo docker ps -l 根据 id 进行 commit, 如果 commit 的内容和原来的 docker 的 tag 一致，那么会替换掉之前 docker 的内容，达到保存的效果 sudo docker commit &lt;commit id&gt; &lt;tag&gt; 1.3 docker 内 Ubuntu20.04 安装 ros2-foxy 启动 docker 内的 Ubuntu20.04: docker run --rm -it --network=host ubuntu:20.04 输入 locale 查看是否支持 utf-8, 如果不支持要安装: apt update &amp;&amp; apt install locales &amp;&amp; locale-gen en_US en_US.UTF-8 &amp;&amp; update-locale LC_ALL=en_US.UTF-8 LANG=en_US.UTF-8 &amp;&amp; export LANG=en_US.UTF-8 添加 ROS2 GPG 密钥：如果出现 403 问题 查看1 ROS2 介绍安装与快速体验 apt update &amp;&amp; apt install curl -y &amp;&amp; curl -sSL https://raw.githubusercontent.com/ros/rosdistro/master/ros.key -o /usr/share/keyrings/ros-archive-keyring.gpg 添加 ros 源： echo \"deb [arch=$(dpkg --print-architecture) signed-by=/usr/share/keyrings/ros-archive-keyring.gpg] http://packages.ros.org/ros2/ubuntu $(. /etc/os-release &amp;&amp; echo $UBUNTU_CODENAME) main\" | tee /etc/apt/sources.list.d/ros2.list &gt; /dev/null 开始安装 ros2-foxy: apt-get update &amp;&amp; apt-get upgrade &amp;&amp; apt-get install ros-foxy-desktop 安装完成之后, 新建一个终端，找到当前 docker 的 id 之后，保存 docker 镜像状态"
  },"/ros2_micro/2023-04-04-4_1_MicroROS%E5%88%9D%E6%AD%A5%E4%BD%93%E9%AA%8C.html": {
    "title": "4 MircoROS 初步体验",
    "keywords": "ROS2_MICRO",
    "url": "/ros2_micro/2023-04-04-4_1_MicroROS%E5%88%9D%E6%AD%A5%E4%BD%93%E9%AA%8C.html",
    "body": "这里还是强烈推荐使用 ros2 humble 也就是 Ubuntu22.04 的默认版本，如果大家是其他版本的，建议使用 docker 来模拟 micro ros 环境sudo docker run -it --net=host -v /dev:/dev --privileged ros:humble 参考内容 micro-ROS 官网教程 从第一个例子来看，应该提前了解的一些基础概念 microROS： microROS 是一个适配于微控制器的 ROS 2 版本，它实现了 ROS 2 的一些核心功能，但是专门为内存和存储资源非常有限的环境优化。它支持多种微控制器架构和 RTOS（实时操作系统），允许这些设备能够在更广泛的 ROS 2 生态系统中进行通信和协作。 microROS Firmware： microROS Firmware 指的是安装在微控制器上的具体固件，这固件包含了 microROS 的客户端库以及为特定微控制器或硬件平台定制的配置。这个固件使得微控制器能够运行 microROS 应用程序，处理如传感器数据收集、执行器控制等任务，并通过 microROS Agent 与 ROS 2 网络中的其他节点进行交互。 microROS Agent： microROS Agent 是一个桥接软件，它允许微控制器（运行 microROS）与运行标凈 ROS 2 的更大的计算系统进行通信。这种通信通常通过网络如串行端口、UDP 或其他通信协议实现。microROS Agent 在较大的系统上运行，作为一个节点接收和发送消息，充当微控制器和其他 ROS 2 实体之间的中介。 4.1 在 Linux 平台上快速体验 MircoROS Tips: 如果你的 rosdep 是有效的话 这个例子是很好跑的, 科学上网很重要，或者采用国内大神的rosdepc 参考 参考内容 First micro-ROS Application on Linux&gt; 4.1.1 下载官网的代码 跟着官网一起来(截止 2024.04.18 这些步骤都是有效的) # Source the ROS 2 installation source /opt/ros/$ROS_DISTRO/setup.bash # Create a workspace and download the micro-ROS tools mkdir microros_ws cd microros_ws git clone -b $ROS_DISTRO https://github.com/micro-ROS/micro_ros_setup.git src/micro_ros_setup # Update dependencies using rosdep # 老版本的ros建议: rosdepc update --include-eol-distros sudo apt update &amp;&amp; rosdep update --include-eol-distros rosdep install --from-paths src --ignore-src -y # 如果说是跑官方例子的话是必须的 不然会出现报错 ''' ERROR: your rosdep installation has not been initialized yet. Please run: sudo rosdep init rosdep update ''' # Install pip # sudo apt-get install python3-pip # Build micro-ROS tools and source them colcon build source install/local_setup.bash 如果出现下面的错误，就手动安装依赖性，例如下下面的sudo apt-get install ros-$ROS_DISTRO-xxx 如果手动安装还是解决不了，很大可能你不是ros-humble造成的，因为在rosdep update时候可能被Skip end-of-life distro \"foxy\"或者是其他版本那么，需要rosdepc update --include-eol-distros了 ERROR: the following packages/stacks could not have their rosdep keys resolved to system dependencies: rclc_lifecycle: Cannot locate rosdep definition for [osrf_testing_tools_cpp] test_msgs: Cannot locate rosdep definition for [test_interface_files] rclc_parameter: Cannot locate rosdep definition for [osrf_testing_tools_cpp] rclc: Cannot locate rosdep definition for [osrf_testing_tools_cpp] Continuing to install resolvable dependencies... 4.1.1 创建 mirco-ros fireware workspace fireware workspace 是做什么的，我在这一步能不能跳过啊？ 问问万能的 GPT： firmware workspace 是一个特殊的目录结构和工作区，用于开发和构建特定于微控制器的固件。这个工作区包括了所有必要的组件来创建和配置微控制器固件，以便它能与 ROS 2 系统兼容和交互。 在这个工作区中，Micro-ROS 的客户端库被配置和编译为固件。这包括生成必要的通信接口和适应层，使微控制器能够通过适当的通信协议（如 UART、TCP/IP 等）与 ROS 2 系统通信。 包含 Micro-ROS 客户端库： Micro-ROS 客户端库是一个适配层，它提供了与 ROS 2 兼容的 API，但优化了内存和处理能力的限制，适用于微控制器。 集成外部库和驱动程序：允许开发者集成硬件特定的驱动程序和中间件，例如用于传感器数据获取和执行器控制的库。 构建和部署工具：提供工具和脚本来构建和部署固件到目标硬件，这些工具通常与微控制器的编程环境（如 ARM Mbed、ESP-IDF 等）集成。 调试和测试：这个工作区也支持固件的调试和测试，这对于确保在资源受限的环境中运行正常至关重要。 这一步是不能够省略的 动手就是干： source install/local_setup.bash &amp;&amp; ros2 run micro_ros_setup create_firmware_ws.sh host 当命令执行完毕后，工作区中应该存在一个名为 firmware 的文件夹，并且 这个步骤的目的是下载一组 micro-ROS 应用程序，到 src/uros/micro-ROS-demos/rclc 路径下，这个 repo 再 GitHub 也是有的，如果你没有出现这两个文件夹 那说明 你这一步操作失败了，用tree -L 2 -I 'install|log'查看 如果你已经有了上面这些文件夹的内容，那么可以开始构建这个 mirco-ros 的全部依赖项了 source install/local_setup.bash &amp;&amp; ros2 run micro_ros_setup build_firmware.sh 如果 build 成功后大概是有 38 个功能包安装好了的: 解释一下这个 micro-ROS-demos，里面的代码都包括两个文件： main.c：应用程序的逻辑。 CMakeLists.txt：编译应用程序的脚本。 如果我们想创建自定义应用程序，就在这个文件夹下创建一个叫的文件夹，其中包含上述两个文件。然后还需要跑到 `src/uros/micro-ROS-demos/rclc/CMakeLists.txt` 中注册，通过添加以下行：`export_executable()`这样注册进来，好了 废话不多说用到再看 4.1.3 体验 MicroROS 的发布和订阅 做完上面两步，是时候来体验mirco-ros的发布和订阅了，其实也就是顺着官网的教程继续往下走,但是官网的ping_pong的例子太麻烦了，我们这之间上后续的发布和订阅的的例子，但是这个例子的条件是你已经走完了上面那一步，有了那些依赖项 参考内容 Publishers and subscribers 创建两个 demo 的源文件夹, 然后就朝着里面的文件进行填内容 mkdir mkdir src/demo_pub &amp;&amp; touch src/demo_pub/main.c &amp;&amp; touch src/demo_pub/CMakeLists.txt &amp;&amp; mkdir src/demo_sub &amp;&amp; touch src/demo_sub/main.c &amp;&amp; touch src/demo_sub/CMakeLists.txt 直接上能跑的发布者代码，注释在代码里，了解基本的内容即可，不得不说现在的 GPT 太强了： 发布者的 main.c demo_pub/main.c #include &lt;rcl/rcl.h&gt; #include &lt;rcl/error_handling.h&gt; #include &lt;rclc/rclc.h&gt; #include &lt;rclc/executor.h&gt; #include &lt;std_msgs/msg/int32.h&gt; #include &lt;stdio.h&gt; #include &lt;unistd.h&gt; // 宏定义用于错误检查，如果发生错误则输出并退出或继续 #define RCCHECK(fn) { rcl_ret_t temp_rc = fn; if((temp_rc != RCL_RET_OK)){printf(\"Failed status on line %d: %d. Aborting.\\n\",__LINE__,(int)temp_rc); return 1;}} #define RCSOFTCHECK(fn) { rcl_ret_t temp_rc = fn; if((temp_rc != RCL_RET_OK)){printf(\"Failed status on line %d: %d. Continuing.\\n\",__LINE__,(int)temp_rc);}} rcl_publisher_t publisher; // 全局发布者对象 std_msgs__msg__Int32 msg; // 整数类型的消息 // 定时器回调函数，每次调用时发布一个消息，并增加计数 void timer_callback(rcl_timer_t * timer, int64_t last_call_time) { (void) last_call_time; if (timer != NULL) { RCSOFTCHECK(rcl_publish(&amp;publisher, &amp;msg, NULL)); printf(\"Sent: %d\\n\", msg.data); msg.data++; } } int main() { rcl_allocator_t allocator = rcl_get_default_allocator(); // 获取默认分配器 rclc_support_t support; // 初始化支持结构 RCCHECK(rclc_support_init(&amp;support, 0, NULL, &amp;allocator)); // 创建节点 rcl_node_t node; RCCHECK(rclc_node_init_default(&amp;node, \"int32_publisher_rclc\", \"\", &amp;support)); // 创建发布者 RCCHECK(rclc_publisher_init_default( &amp;publisher, &amp;node, ROSIDL_GET_MSG_TYPE_SUPPORT(std_msgs, msg, Int32), \"std_msgs_msg_Int32\")); // 创建定时器 rcl_timer_t timer; const unsigned int timer_timeout = 1000; // 定时器超时时间为1000毫秒 RCCHECK(rclc_timer_init_default( &amp;timer, &amp;support, RCL_MS_TO_NS(timer_timeout), timer_callback)); // 创建执行器 rclc_executor_t executor = rclc_executor_get_zero_initialized_executor(); RCCHECK(rclc_executor_init(&amp;executor, &amp;support.context, 1, &amp;allocator)); RCCHECK(rclc_executor_add_timer(&amp;executor, &amp;timer)); msg.data = 0; // 初始化消息数据 rclc_executor_spin(&amp;executor); // 执行器开始执行 // 清理资源 RCCHECK(rcl_publisher_fini(&amp;publisher, &amp;node)); RCCHECK(rcl_node_fini(&amp;node)); } 发布者的 CMakeLists.txt 文件内容：(demo_pub/CMakeLists.txt)[https://github.com/micro-ROS/micro-ROS-demos/blob/humble/rclc/int32_publisher/CMakeLists.txt] # 设置CMake的最低版本要求为3.5 cmake_minimum_required(VERSION 3.5) # 定义项目名称和使用的编程语言 project(demo_pub LANGUAGES C) # 寻找CMake的ament包管理工具，这是ROS 2中常用的包管理工具 find_package(ament_cmake REQUIRED) # 寻找必要的包，这些包提供ROS 2和microROS的功能 find_package(rcl REQUIRED) # ROS 2 client library (rcl) find_package(rclc REQUIRED) # ROS 2 client library for the C language (rclc) find_package(std_msgs REQUIRED) # 标准消息定义，用于ROS 2通信 find_package(rmw_microxrcedds REQUIRED) # 为microROS提供的中间件实现 # 添加一个可执行文件目标，名为项目名称，源代码文件为 main.c add_executable(${PROJECT_NAME} main.c) # 将上述找到的包作为编译目标的依赖项 ament_target_dependencies(${PROJECT_NAME} rcl rclc std_msgs rmw_microxrcedds ) # 安装构建的可执行文件到安装目录下的项目名称文件夹中 install(TARGETS ${PROJECT_NAME} DESTINATION ${PROJECT_NAME} ) 直接上能跑的订阅者的代码，解释全部再注释内，了解过程即可 订阅者的 main.c int32_publisher_subscriber/main.c #include &lt;rcl/rcl.h&gt; #include &lt;rcl/error_handling.h&gt; #include &lt;rclc/rclc.h&gt; #include &lt;rclc/executor.h&gt; #include &lt;std_msgs/msg/int32.h&gt; #include &lt;stdio.h&gt; // 宏定义用于检查函数返回值，并在出现错误时输出错误信息 #define RCCHECK(fn) { rcl_ret_t temp_rc = fn; if((temp_rc != RCL_RET_OK)){printf(\"Failed status on line %d: %d. Aborting.\\n\",__LINE__,(int)temp_rc); return 1;}} #define RCSOFTCHECK(fn) { rcl_ret_t temp_rc = fn; if((temp_rc != RCL_RET_OK)){printf(\"Failed status on line %d: %d. Continuing.\\n\",__LINE__,(int)temp_rc);}} rcl_publisher_t publisher; // 发布者对象 rcl_subscription_t subscriber; // 订阅者对象 std_msgs__msg__Int32 send_msg; // 发送的消息 std_msgs__msg__Int32 recv_msg; // 接收的消息 // 定时器回调函数，用于周期性发布消息 void timer_callback(rcl_timer_t * timer, int64_t last_call_time) { (void) last_call_time; // 忽略未使用的参数 if (timer != NULL) { RCSOFTCHECK(rcl_publish(&amp;publisher, &amp;send_msg, NULL)); printf(\"Sent: %d\\n\", send_msg.data); send_msg.data++; } } // 订阅者回调函数，当接收到新消息时被调用 void subscription_callback(const void * msgin) { const std_msgs__msg__Int32 * msg = (const std_msgs__msg__Int32 *)msgin; printf(\"Received: %d\\n\", msg-&gt;data); } int main(int argc, const char * const * argv) { rcl_allocator_t allocator = rcl_get_default_allocator(); // 获取默认分配器 rclc_support_t support; // 初始化支持结构，用于配置ROS 2通信 RCCHECK(rclc_support_init(&amp;support, argc, argv, &amp;allocator)); // 创建节点 rcl_node_t node; RCCHECK(rclc_node_init_default(&amp;node, \"int32_publisher_subscriber_rclc\", \"\", &amp;support)); // 创建发布者 RCCHECK(rclc_publisher_init_default( &amp;publisher, &amp;node, ROSIDL_GET_MSG_TYPE_SUPPORT(std_msgs, msg, Int32), \"int32_publisher\")); // 创建订阅者 RCCHECK(rclc_subscription_init_default( &amp;subscriber, &amp;node, ROSIDL_GET_MSG_TYPE_SUPPORT(std_msgs, msg, Int32), \"int32_subscriber\")); // 创建定时器，设置超时时间为1000毫秒 rcl_timer_t timer; const unsigned int timer_timeout = 1000; RCCHECK(rclc_timer_init_default( &amp;timer, &amp;support, RCL_MS_TO_NS(timer_timeout), timer_callback)); // 创建执行器，并添加定时器和订阅者 rclc_executor_t executor = rclc_executor_get_zero_initialized_executor(); RCCHECK(rclc_executor_init(&amp;executor, &amp;support.context, 2, &amp;allocator)); RCCHECK(rclc_executor_add_timer(&amp;executor, &amp;timer)); RCCHECK(rclc_executor_add_subscription(&amp;executor, &amp;subscriber, &amp;recv_msg, &amp;subscription_callback, ON_NEW_DATA)); send_msg.data = 0; // 初始化发送消息的数据 // 运行执行器，开始处理事件 rclc_executor_spin(&amp;executor); // 清理资源，销毁发布者、订阅者和节点 RCCHECK(rcl_subscription_fini(&amp;subscriber, &amp;node)); RCCHECK(rcl_publisher_fini(&amp;publisher, &amp;node)); RCCHECK(rcl_node_fini(&amp;node)); } 订阅者的 CMakeLists int32_publisher_subscriber/CMakeLists.txt cmake_minimum_required(VERSION 3.5) project(demo_sub LANGUAGES C) find_package(ament_cmake REQUIRED) find_package(rcl REQUIRED) find_package(rclc REQUIRED) find_package(std_msgs REQUIRED) find_package(rmw_microxrcedds REQUIRED) add_executable(${PROJECT_NAME} main.c) ament_target_dependencies(${PROJECT_NAME} rcl rclc std_msgs rmw_microxrcedds ) install(TARGETS ${PROJECT_NAME} DESTINATION ${PROJECT_NAME} ) 编译运行 查看效果 colcon build 4.2 使用 ESP32 发布话题 体验 MircoROS 的通讯 Tips: 需要完成上面的micro ros 的 fireware workspace的构建 参考内容 ROS2 与 arduino 入门教程-安装 micro_ros_arduino Arduino 配置 micro-ros 安装 arduino ide并下载esp32的开发工具包， 网上搜索一大堆 添加 mirco_ros_arduino到库内 到 GitHub 仓库的 release 下，下载对应 ROS 版本的 zip 包：micro-ROS/micro_ros_arduino 添加 Zip 包到arduino-ide内: 跑 demo 例子 接入 esp32 板卡 需要下载pyserial: sudo pip install pyserial 给板卡端口赋权限sudo chmod 777 /dev/ttyUSB0 或者是 sudo chmod 777 /dev/ttyACM0等其他 就看你的开发板端口了 选择 micro-ros-publish例子烧录 查看你的板卡烧录情况 主机测试连接情况 回到上述的microros_ws下， 构建micro_ros_agent: source install/local_setup.bash &amp;&amp; ros2 run micro_ros_setup build_agent.sh 构建完成之后测试"
  },"/ros2_micro/2023-04-03-3_1_ROS2_Arduino_demo.html": {
    "title": "3 ROS2 和 arduino 通讯",
    "keywords": "ROS2_MICRO",
    "url": "/ros2_micro/2023-04-03-3_1_ROS2_Arduino_demo.html",
    "body": "3.1 基本介绍 在完成了上面两个简单的 arduino 的例子之后 也能用 python 从串口拿到消息，然后做 ROS2 消息的转发 接下来我们就可以对拿到的消息做处理 处理主要: Python 从串口中读取消息的功能模块 Python 发送消息给到 ROS2 的节点的格式(Twist) 有了上面两个辅助的模块，就可以创建一个 ROS2 的节点，在不断的从串口获取数据，然后解析数据转成控制 ROS2 turtlesim 的消息 那么 我们的文件夹结构就是这样的 ros2_arduino_demo/ |-- main.py // 主要的控制逻辑和ROS2节点 |-- move_instruction.py // 辅助生成控制消息的模块，简单的模拟管理机器人是不是要急停 `-- read_serial.py // 连接串口和读取串口信息 1 directory, 3 files 3.2 实现的效果 遥控器控制机器人移动 距离传感器报警之后机器人急停，解除之后恢复 3.3 处理串口消息的模块 read_serial.py 废话不多说 直接看代码 这个比较简单 ''' 利用pyserial从串口中获得消息,转成指令 ''' import serial class ReadSerial: def __init__(self) -&gt; None: # 串口的句柄 self.ser = serial.Serial() def open_serial(self, port, baudrate) -&gt; bool: '''连接打开串口''' try: # 打开串口 self.ser = serial.Serial(port, baudrate, timeout=1) print(f\"Connected to {port} at {baudrate} baud.\") return True except serial.SerialException as e: print(f\"Error: {e}\") return False def read_from_serial(self) -&gt; str: '''读取串口的消息''' try: line = self.ser.readline().decode('utf-8').strip() if line != None: # 处理数据 return line except Exception as e: print(f\"Read data from serial error {e}\") return '' 3.4 发送 ROS2 cmd_vel 运动指令的模块 move_instruction.py 这个也比较简单 直接看代码 ''' 接收指令控制机器人移动,也就是根据某个字符发送对应的运动指令 ''' from geometry_msgs.msg import Twist class MoveInstruction(): def __init__(self): # 急停的标志 self.is_estop = False # 收到消息要发送的行为 self.twist = Twist() def move_msg(self, key) -&gt; Twist: # 急停不做任何操作 if self.is_estop: return self.e_stop() if key == 'w' or key == '2': # 向前移动 self.twist.linear.x = 2.0 self.twist.angular.z = 0.0 elif key == 'x' or key == '8': # 向后移动 self.twist.linear.x = -2.0 self.twist.angular.z = 0.0 elif key == 'd' or key == '6': # 向右转 self.twist.linear.x = 0.0 self.twist.angular.z = -2.0 elif key == 'a' or key == '4': # 向左转 self.twist.linear.x = 0.0 self.twist.angular.z = 2.0 elif key == 'q' or key == '1': # 左上旋转 self.twist.linear.x = 2.0 self.twist.angular.z = 2.0 elif key == 'e' or key == '3': # 右上旋转 self.twist.linear.x = 2.0 self.twist.angular.z = -2.0 elif key == 'z' or key == '7': # 左下旋转 self.twist.linear.x = -2.0 self.twist.angular.z = 2.0 elif key == 'c' or key == '9': # 右下旋转 self.twist.linear.x = -2.0 self.twist.angular.z = -2.0 elif key == 's' or key == '5': # 停止 self.twist.linear.x = 0.0 self.twist.angular.z = 0.0 else: # 无效指令也停止 self.twist.linear.x = 0.0 self.twist.angular.z = 0.0 return self.twist def e_stop(self): '''急停状态全置0, 设置flag''' self.is_estop = True self.twist.linear.x = 0.0 self.twist.linear.y = 0.0 self.twist.linear.z = 0.0 self.twist.angular.x = 0.0 self.twist.angular.y = 0.0 self.twist.angular.z = 0.0 return self.twist def resume(self): '''退出estop状态''' if self.is_estop: self.is_estop = False 唯一值得一提的就是 geometry_msgs.msg.Twist 消息是 ROS 中用于表示速度的消息类型，它包含两个主要部分：线速度（linear）和角速度（angular）。这两个部分都是 geometry_msgs.Vector3 类型。Twist 消息包含以下参数： linear：线速度（geometry_msgs.Vector3 类型） x：沿 x 轴的线速度 y：沿 y 轴的线速度 z：沿 z 轴的线速度 angular：角速度（geometry_msgs.Vector3 类型） x：绕 x 轴的角速度 y：绕 y 轴的角速度 z：绕 z 轴的角速度 在 TurtleSim 通常只会用到 linear.x 和 angular.z，因为乌龟只在 2D 平面上移动。 3.5 ROS2 节点 main.py 这个才是重中之重, 主要的实现也就如下所示 那么这时候看代码就清楚了 ''' 处理串口消息，增加各种逻辑，创建控制机器人运动的节点 ''' import time import rclpy from rclpy.node import Node from geometry_msgs.msg import Twist from move_instruction import MoveInstruction from read_serial import ReadSerial # 定义几个常量 NODE_NAME = 'ros2_arduino_demo' PUB_TOPIC = '/turtle1/cmd_vel' SER_PORT_NAME = '/dev/ttyUSB0' SER_BAUD_RATE = 57600 # 约定的串口消息的分隔符 SPLIT_SYMBOL = '=' # 红外传感器串口消息的关键字 IRREMOTE_KEY = 'MOVE' # 声波传感器的关键字 ESTOP_KEY = 'ESTOP' class ROS2ArduinoDemo(Node): def __init__(self): # ROS2的基本节点信息 super().__init__(NODE_NAME) self.publisher_ = self.create_publisher(Twist, PUB_TOPIC, 10) # 读取传感器和发送消息的句柄 self.ins_handler = MoveInstruction() self.ser_handler = ReadSerial() def run(self): '''开始执行ROS2节点''' # 连接串口 flag = self.ser_handler.open_serial(SER_PORT_NAME, SER_BAUD_RATE) if not flag: print(\"exit ... ...\") exit(0) # 要发送的控制消息 twist = Twist() # 开始循环接收串口消息，用串口的消息来控制机器人 while True: ser_data_str = self.ser_handler.read_from_serial() # 无效信息 if ser_data_str == '': continue # 字符串处理 ser_data_arr = ser_data_str.split(SPLIT_SYMBOL) # 数组长度不为2 也是无效信息 if len(ser_data_arr) != 2: continue if ser_data_arr[0] == ESTOP_KEY: # 急停 if ser_data_arr[1] == '1': twist = self.ins_handler.e_stop() self.publisher_.publish(twist) print(\"stop!\") else: # 退出急停 self.ins_handler.resume() # 处理红外的信号控制运行 elif ser_data_arr[0] == IRREMOTE_KEY: twist = self.ins_handler.move_msg(ser_data_arr[1]) self.publisher_.publish(twist) else: # 其他消息无操作 pass if __name__ == '__main__': rclpy.init(args=None) node = ROS2ArduinoDemo() node.run() node.destroy_node() rclpy.shutdown() 3.6 总结 用串口的方式处理 arduino 和 ROS2 的通讯，这种模式可以适用到其他的单片机上 控制机器人的运动在考虑急停时候也就是考虑不让 cmd_vel 发送有效速度信息即可 后面有更复杂的在导航过程的通讯，可以用 action 来做, 这里不介绍了，用到再看"
  },"/ros2_micro/2023-04-02-2_1_Arduino%E5%9F%BA%E6%9C%AC%E8%AF%AD%E6%B3%95.html": {
    "title": "2 Arduino 的基本语法",
    "keywords": "ROS2_MICRO",
    "url": "/ros2_micro/2023-04-02-2_1_Arduino%E5%9F%BA%E6%9C%AC%E8%AF%AD%E6%B3%95.html",
    "body": "2.1 暂无 2.2 Arduino 用 IRremote 库使用红外模块 2.2.1 结果 话不多说 直接上结果，打开窗口 就能看见获得的红外信号 2.2.2 接线 这个没啥好说的 就一个信号线 Pin Description VCC Powers the sensor (5V) Data Pin 11 GND Common GND 2.2.3 实现代码 #include \"IRremote.h\" int IR_RECEIVE_PIN = 11; // 红外传输的数据引脚 long lastReceivedValue = 0; // 存储上一次接收到的红外信号值 unsigned long lastTimeReceived = 0; // 存储上一次接收到红外信号的时间 int debounceDelay = 50; // 可调延迟参数 IRrecv irrecv(IR_RECEIVE_PIN); // 红外模块初始化 decode_results results; // 用于存放红外模块返回的数据 void setup() { pinMode(LED_BUILTIN, OUTPUT); // 显示指示灯 Serial.begin(57600); // 设置Arduino通信的波特率 irrecv.enableIRIn(); Serial.println(\"Enabling IRin\"); // 串口打印消息 } void loop() { if (irrecv.decode(&amp;results)) { // 检查是否接收到无效信号或是否间隔了一段时间（防止信号抖动） if ((results.value != 0xFFFFFFFF &amp;&amp; results.value != 0x00000000) &amp;&amp; (results.value != lastReceivedValue || millis() - lastTimeReceived &gt; debounceDelay)) { Serial.println(results.value); // 打印十进制数据 Serial.println(results.value, HEX); // 打印十六进制数据 Serial.println(\"======================\"); // 更新上一次接收到的信号值和时间 lastReceivedValue = results.value; lastTimeReceived = millis(); } else if (results.value == 0xFFFFFFFF || results.value == 0x00000000) { // 打印上次的值 Serial.println(lastReceivedValue, HEX); Serial.println(\"======================\"); } irrecv.resume(); // 接收下一个值 } delay(debounceDelay); // 延迟时间设为可调参数 } 后续根据按键接收到的信号值 做 switch 判断按了哪个按键即可 2.3 Arduino 使用 HC-SR04 超声波模块 2.3.1 结果 话不多说 直接上结果，打开窗口 就能看见获得的距离消息 2.3.2 接线 参考内容: Complete Guide for Ultrasonic Sensor HC-SR04 with Arduino 冷知识 Power Supply :+5V DC Quiescent Current : &lt;2mA Working Current: 15mA Effectual Angle: &lt;15° Ranging Distance : 2cm – 400 cm/1″ – 13ft Resolution : 0.3 cm Measuring Angle: 30 degree Trigger Input Pulse width: 10uS TTL pulse Echo Output Signal: TTL pulse proportional to the distance range Dimension: 45mm x 20mm x 15mm Pin Description VCC Powers the sensor (5V) Trig Trigger Input Pin 11 Echo Echo Output Pin 12 GND Common GND 2.3.3 代码实现 可运行的最小 ino 代码 const int trigPin = 9; // 定义触发引脚为9 const int echoPin = 10; // 定义回声引脚为10 float duration, distance; // 定义两个浮点变量：duration用于存储超声波的往返时间，distance用于存储计算得到的距离 void setup() { pinMode(trigPin, OUTPUT); // 将触发引脚设置为输出模式 pinMode(echoPin, INPUT); // 将回声引脚设置为输入模式 Serial.begin(57600); // 初始化串口通信，波特率设置为57600 } void loop() { // 发送一个超声波脉冲 digitalWrite(trigPin, LOW); // 确保触发引脚初始为低电平 delayMicroseconds(2); // 等待2微秒 digitalWrite(trigPin, HIGH); // 将触发引脚拉高，发送超声波脉冲 delayMicroseconds(10); // 保持高电平10微秒，以产生一个超声波脉冲 digitalWrite(trigPin, LOW); // 将触发引脚拉低，结束脉冲 // 读取回声引脚的信号 duration = pulseIn(echoPin, HIGH); // 读取回声引脚高电平持续的时间（微秒） // 计算距离 distance = (duration * 0.0343) / 2; // 将时间转换为距离，单位为厘米 // 超声波在空气中的速度约为343米/秒（0.0343厘米/微秒） // 因为时间是往返时间，所以除以2得到单程距离 // 输出距离到串口监视器 Serial.print(\"Distance: \"); Serial.println(distance); delay(100); // 延时100毫秒，等待下一次测量 } 2.4 Arduino 同时运行多个功能代码 2.4.1 结果 同时运行红外和距离传感器功能，而且不会阻塞一方 2.4.2 文件结构 文件夹结构是打开项目的最关键的内容 创建一个名为 Arduino_Demo 的文件夹，并在该文件夹中包含一个名为 Arduino_Demo.ino 的文件, 这种命名方式有助于保持项目的一致性和可识别性，便于后续管理和开发, 也是 Arduino IDE 识别项目的关键 . `-- Arduino_Demo |-- Arduino_Demo.ino // 烧录代码的入口 |-- HCSHandler.cpp // 声波传感器实现代码 |-- HCSHandler.hpp // 声波传感器的头文件 |-- HCSR04_Demo.txt // 上面文件夹的ino文件的备份，可以删除 不重要 |-- IRHandler.cpp // 红外传感器的实现 |-- IRHandler.hpp // 红外传感器的头文件 |-- IRremote_Demo.txt // 上面文件夹的ino文件的备份，可以删除 不重要 `-- ReadSerialData.py // 利用python读取串口信息的demo文件，可以不要 1 directory, 8 files 2.4.2 .cpp/.hpp 代码实现 这些代码其实在上面内容都是有的 只是做了一些实际上有用的消息的包装，不过多介绍了，很简单 HCSHandler.hpp #ifndef HCSHANDLER_H #define HCSHANDLER_H #ifdef __cplusplus extern \"C\" { #endif void HSCHandler_init(int trigPin, int echoPin); // 初始化函数，设置引脚和模式 void HSCHandler_getDistance(); // 获取距离函数，返回测量的距离 #ifdef __cplusplus } #endif #endif HCSHandler.cpp #include \"HCSHandler.hpp\" #include \"Arduino.h\" static int trigPin; // 触发引脚 static int echoPin; // 回声引脚 static float duration; // 超声波往返时间 static float distance; // 计算得到的距离 // 初始化函数，设置引脚和模式 void HSCHandler_init(int tPin, int ePin) { trigPin = tPin; echoPin = ePin; pinMode(trigPin, OUTPUT); pinMode(echoPin, INPUT); } // 获取距离函数，返回测量的距离 void HSCHandler_getDistance() { int estopFlag = 0; // 0表示无距离危险 // 发送一个超声波脉冲 digitalWrite(trigPin, LOW); delayMicroseconds(2); digitalWrite(trigPin, HIGH); delayMicroseconds(10); digitalWrite(trigPin, LOW); // 读取回声引脚高电平持续的时间（微秒） duration = pulseIn(echoPin, HIGH); // 将时间转换为距离，单位为厘米 // 超声波在空气中的速度约为343米/秒（0.0343厘米/微秒） // 因为时间是往返时间，所以除以2得到单程距离 distance = (duration * 0.0343) / 2; if(distance &lt; 20) { estopFlag = 1; } // 输出距离到串口监视器 Serial.print(\"ESTOP=\"); Serial.println(estopFlag); delay(100); // 延时100毫秒，等待下一次测量 } IRHandler.hpp #ifndef IRHANDLER_H #define IRHANDLER_H #ifdef __cplusplus extern \"C\" { #endif void setupIR(int pin); // 初始化 void handleIR(); // 处理信号 int mapNum(unsigned long int decode); // 匹配按键 #ifdef __cplusplus } #endif #endif IRHandler.cpp #include \"IRHandler.hpp\" #include \"IRremote.h\" static int IR_RECEIVE_PIN = 11; // 红外传输的数据引脚 static long lastReceivedValue = 0; // 存储上一次接收到的红外信号值 static unsigned long lastTimeReceived = 0; // 存储上一次接收到红外信号的时间 static int debounceDelay = 100; // 可调延迟参数 IRrecv irrecv(IR_RECEIVE_PIN); // 红外模块初始化 decode_results results; // 用于存放红外模块返回的数据 void setupIR(int pin) { IR_RECEIVE_PIN = pin; pinMode(LED_BUILTIN, OUTPUT); // 显示指示灯 irrecv.enableIRIn(); Serial.println(\"Enabling IRin\"); // 串口打印消息 } int mapNum(unsigned long int decode) { int num = 99; // 99 表示无效内容 switch (decode) { case 0xFFA25D: num = 1; break; case 0xFF629D: num = 2; break; case 0xFFE21D: num = 3; break; case 0xFF22DD: num = 4; break; case 0xFF02FD: num = 5; break; case 0xFFC23D: num = 6; break; case 0xFFE01F: num = 7; break; case 0xFFA857: num = 8; break; case 0xFF906F: num = 9; break; case 0xFF6897: num = 10; break; case 0xFF9867: num = 11; break; case 0xFFB04F: num = 12; break; case 0xFF18E7: num = 13; break; case 0xFF10EF: num = 14; break; case 0xFF38C7: num = 15; break; case 0xFF5AA5: num = 16; break; case 0xFF4AB5: num = 17; break; default: num = 99; break; } return num; } void handleIR() { int moveNum = 99; if (irrecv.decode(&amp;results)) { // 检查是否接收到无效信号或是否间隔了一段时间（防止信号抖动） if ((results.value != 0xFFFFFFFF &amp;&amp; results.value != 0x00000000) &amp;&amp; (results.value != lastReceivedValue || millis() - lastTimeReceived &gt; debounceDelay)) { moveNum = mapNum(results.value); Serial.print(\"MOVE=\"); Serial.println(moveNum); // 更新上一次接收到的信号值和时间 lastReceivedValue = results.value; lastTimeReceived = millis(); } else if (results.value == 0xFFFFFFFF || results.value == 0x00000000) { // 打印上次的值 moveNum = mapNum(lastReceivedValue); Serial.print(\"MOVE=\"); Serial.println(moveNum); } irrecv.resume(); // 接收下一个值 } delay(debounceDelay); // 延迟时间设为可调参数 } 2.4.3 Arduino_Demo.ino 代码实现 直接看代码，从代码角度来分析为什么这样写 关键点在于 用cpp/hpp管理具体的实现，结构好看 引入各个功能到 loop 里 即可实现全部的功能 使用 millis() 进行非阻塞时间管理 定时检查并获取声波传感器距离：HSCHandler_getDistance() 定时处理红外传感器信号：handleIR() #include \"HCSHandler.hpp\" #include \"IRHandler.hpp\" const int trigPin = 9; // 定义声波传感器触发引脚为9 const int echoPin = 10; // 定义声波传感器回声引脚为10 const int irremotePin = 11; // 定义红外的信号引脚为11 // 模仿多线程,也就是划分时间做某个函数的事情 unsigned long lastDistanceCheck = 0; // 存储上一次接收到声波传感器的时间 unsigned long lastIRCheck = 0; // 存储上一次接收到红外信号的时间 const unsigned long distanceInterval = 100; // 检查距离的时间间隔 const unsigned long irInterval = 100; // 检查红外信号的时间间隔 void setup() { Serial.begin(57600); // 初始化串口通信，波特率设置为57600 HSCHandler_init(trigPin, echoPin); // 初始化声波传感器 setupIR(irremotePin); // 初始化红外传感器 } void loop() { unsigned long currentMillis = millis(); // 非阻塞地处理超声波测距 if (currentMillis - lastDistanceCheck &gt;= distanceInterval) { lastDistanceCheck = currentMillis; HSCHandler_getDistance(); // 获取声波传感器距离 } // 非阻塞地处理红外传感器 if (currentMillis - lastIRCheck &gt;= irInterval) { lastIRCheck = currentMillis; handleIR(); // 处理红外传感器 } } 2.5 利用 python 的 pyserial 库读取串口信息 2.5.1 结果 2.5.2 代码实现 直接上代码吧，这个太简单了, 需要安装 pyserial 库 pip3 install pyserial # sudo pip3 install pyserial import serial def read_from_serial(port, baudrate): try: # 打开串口 ser = serial.Serial(port, baudrate, timeout=1) print(f\"Connected to {port} at {baudrate} baud.\") while True: # 读取一行数据 line = ser.readline().decode('utf-8').strip() if line: print(f\"Received: {line}\") except serial.SerialException as e: print(f\"Error: {e}\") except KeyboardInterrupt: print(\"Exiting...\") finally: # 关闭串口 if ser.is_open: ser.close() print(\"Serial port closed.\") # 调用函数读取COM18端口的消息，波特率为57600 read_from_serial('COM18', 57600)"
  },"/ros2_micro/2023-04-01-1_1_ROS2_Arduino.html": {
    "title": "1 ROS2 和 Arduino 通讯",
    "keywords": "ROS2_MICRO",
    "url": "/ros2_micro/2023-04-01-1_1_ROS2_Arduino.html",
    "body": "ROS2 和 Arduino 的通讯方式有很多，个人觉得只要分为两大类 第一类是采用 ros2arduino 或者 MicroROS 这类的包，在 arduino 板卡上尝试直接进行 ros2 的节点的发布和订阅, 然后主机上则采用对应的 DDS 工具 例如 MicroROS 的各种通讯中间件，Mirco_XRCE_DDS 图像中间件，或者是 ros2_serial 获取发布订阅的串口数据的中间件 直接从微控制器本身出发，Arduino 直接烧录自身的功能代码 而不依赖仍和 ROS2 相关的库，然后用 Python 或者 C/C++编写接受串口消息的节点，做发布和订阅 那么这里就采用第二种方式，最简单快速的完成 ROS2 和 Arduino 的通讯"
  },"/ros2_basic/2023-02-05-4_1_ROS2%E5%8F%82%E6%95%B0%E6%9C%8D%E5%8A%A1%E5%99%A8.html": {
    "title": "4 ROS2节点参数基础",
    "keywords": "ROS2_BASIC",
    "url": "/ros2_basic/2023-02-05-4_1_ROS2%E5%8F%82%E6%95%B0%E6%9C%8D%E5%8A%A1%E5%99%A8.html",
    "body": "4.1 ROS2节点参数介绍 参考内容 Understanding parameters 在ROS2的通讯过程中，有一种信息记录某个节点的特征，例如turtlesim仿真时候的乌龟类型，背景的颜色等等，这一类节点设置的数据，通常采用节点参数(parameters)进行设置和操作，可以把节点参数认为是对节点的设置，可以对参数进行增删改查的操作 4.2 使用C/C++实现对节点参数的增删改查 示例创建一个节点参数的服务端，和一个节点参数的客户端，服务端用于实现后续客户端对它的参数进行增删改查操作 参考内容 Using parameters in a class (C++) 2.5.3_参数服务_C++实现_03客户端_01代码框架 4.2.1 创建C/C++节点参数的服务端 创建功能包，包名为cpp_para_ser，节点名为cppParaSerNode，依赖rclcpp：ros2 pkg create cpp_para_server --build-type ament_cmake --node-name cppParaSerNode --dependencies rclcpp 配置Vscode环境，在工作空间创建.vscode文件夹，并加入settings.json文件，添加ROS2的include环境： { \"C_Cpp.default.includePath\": [ \"/opt/ros/humble/include/**\", ], } 创建节点参数服务：注意删除节点的参数，只能删除未被声明的内容： // 1. 生成节点的头文件 #include \"rclcpp/rclcpp.hpp\" // 2. 定义节点参数服务端 class CppParamServer : public rclcpp::Node { public: // 2.1 构造函数，设置节点名，以及允许被删除的内容 CppParamServer() : Node(\"cppParamSerNode\",rclcpp::NodeOptions().allow_undeclared_parameters(true)) {} // 2.2 创建默认的参数表 void declare_param() { // 2.2.1 声明参数并设置默认值 this-&gt;declare_parameter(\"name\", \"zhangsan\"); this-&gt;declare_parameter(\"height\", \"1.8\"); // 2.2.2 未声明的参数，该参数可以被删除 this-&gt;set_parameter(rclcpp::Parameter(\"age\", \"20\")); } // 3 获取到现在的所有参数 void get_AllValue() { RCLCPP_INFO(this-&gt;get_logger(), \"------------------ Get the params ----------------\"); auto params = this-&gt;get_parameters({\"name\", \"height\", \"age\"}); for (auto &amp;param : params) { // 3.1 get_name函数获取参数名，value_to_string获取到参数的字符串值 RCLCPP_INFO(this-&gt;get_logger(), \"parameter is %s, the value is %s\", param.get_name().c_str(), param.value_to_string().c_str()); } } // 4 修改参数 void update_param() { RCLCPP_INFO(this-&gt;get_logger(), \"------------------ Change the value ----------------\"); this-&gt;set_parameter(rclcpp::Parameter(\"name\", \"lisi\")); this-&gt;get_AllValue(); } // 5. 删除参数 void del_param() { RCLCPP_INFO(this-&gt;get_logger(), \"------------------ Delete ----------------\"); // 5.1 删除只能删除未声明的参数，不能删除声明过的参数 this-&gt;undeclare_parameter(\"age\"); auto params = this-&gt;get_parameters({\"name\", \"height\"}); for (auto &amp;param : params) { // 5.1 get_name函数获取参数名，value_to_string获取到参数的字符串值 RCLCPP_INFO(this-&gt;get_logger(), \"parameter is %s, the value is %s\", param.get_name().c_str(), param.value_to_string().c_str()); } } }; int main(int argc, char **argv) { rclcpp::init(argc, argv); auto paramServer = std::make_shared&lt;CppParamServer&gt;(); // 执行对应的函数 paramServer-&gt;declare_param(); paramServer-&gt;get_AllValue(); paramServer-&gt;update_param(); paramServer-&gt;del_param(); rclcpp::spin(paramServer); rclcpp::shutdown(); return 0; } 由于在创建包的过程中已经指明了所有依赖项，不需要进行额外的配置，直接编译运行即可：colcon build --packages-select cpp_para_server 激活环境并运行节点：. install/setup.bash和ros2 run cpp_para_server cppParaSerNode 4.2.2 创建C/C++节点参数客户端 创建功能包，包名为cpp_para_client，节点名为cppParaCliNode，依赖rclcpp：ros2 pkg create cpp_para_client --build-type ament_cmake --node-name cppParaCliNode --dependencies rclcpp 配置Vscode环境，在工作空间创建.vscode文件夹，并加入settings.json文件，添加ROS2的include环境： { \"C_Cpp.default.includePath\": [ \"/opt/ros/humble/include/**\", ], } 创建节点参数客户端，值得注意的是需要连接到服务端节点，然后进行参数的增删改查操作： // 1.包含头文件； #include \"rclcpp/rclcpp.hpp\" using namespace std::chrono_literals; // 2.定义节点类； class CppParaClient : public rclcpp::Node { public: CppParaClient() : Node(\"cppParaCliNode\") { // 2.1 连接到节点参数的服务节点,注意此时的第二个参数是连接的服务端节点名 paramClient = std::make_shared&lt;rclcpp::SyncParametersClient&gt;(this, \"cppParamSerNode\"); } // 3. 连接服务函数 bool connect_server() { // 3.1 等待服务连接 while (!paramClient-&gt;wait_for_service(1s)) { if (!rclcpp::ok()) { return false; } RCLCPP_INFO(this-&gt;get_logger(), \"The server connect failed! \"); } return true; } // 4. 查询参数 void get_values() { RCLCPP_INFO(this-&gt;get_logger(), \"----------- Get the values -----------\"); auto params = paramClient-&gt;get_parameters({\"name\", \"height\"}); for (auto &amp;param : params) { RCLCPP_INFO(this-&gt;get_logger(), \"%s = %s\", param.get_name().c_str(), param.value_to_string().c_str()); } } // 5. 修改参数 void update_param() { RCLCPP_INFO(this-&gt;get_logger(), \"----------- Change the values -----------\"); paramClient-&gt;set_parameters({rclcpp::Parameter(\"name\", \"lisi\"), // 这是服务端不存在的参数，只有服务端设置了rclcpp::NodeOptions().allow_undeclared_parameters(true)时， // 这个参数才会被成功设置。 rclcpp::Parameter(\"sex\", \"man\")}); } private: rclcpp::SyncParametersClient::SharedPtr paramClient; }; int main(int argc, char const *argv[]) { rclcpp::init(argc, argv); // 4.创建节点对象指针，调用参数操作函数； auto paramClient = std::make_shared&lt;CppParaClient&gt;(); bool flag = paramClient-&gt;connect_server(); if (!flag) { return 0; } paramClient-&gt;get_values(); paramClient-&gt;update_param(); paramClient-&gt;get_values(); // 5.释放资源。 rclcpp::shutdown(); return 0; } 由于在创建包的过程中已经指明了所有依赖项，不需要进行额外的配置，直接编译运行即可：colcon build --packages-select cpp_para_client 激活环境并运行节点：. install/setup.bash，先运行服务端节点ros2 run cpp_para_server cppParaSerNode，然后运行客户端节点ros2 run cpp_para_client cppParaCliNode 4.3 使用Python实现对节点参数的增删改查 参考内容 Using parameters in a class (Python) 2.5.4_参数服务_Python实现_01框架搭建 4.3.1 创建Python节点参数的服务端 创建功能包，包名为python_para_ser，节点名为pythonParaSerNode，依赖rclpy：ros2 pkg create python_para_ser --build-type ament_python --node-name pythonParaSerNode --dependencies rclpy 配置Vscode环境，在工作空间创建.vscode文件夹，并加入settings.json文件，添加ROS2的include环境： { \"C_Cpp.default.includePath\": [ \"/opt/ros/humble/include/**\" ], \"python.analysis.include\": [ \"/opt/ros/humble/local/lib/python3.10/dist-packages/**\" ] } 创建节点参数服务：注意删除节点的参数，只能删除未被声明的内容： # 1. 导入包 import rclpy from rclpy.node import Node # 2. 创建节点参数服务节点 class PythonParaServer(Node): def __init__(self): # 2.1 构造函数 super().__init__(\"pythonParaSerNode\",allow_undeclared_parameters=True) # 3 声明节点参数 def declare_param(self): self.declare_parameter(\"name\",\"zhangsan\") self.declare_parameter(\"height\",1.88) # 3.1 声明未声明的参数，可以被删除 self.age = rclpy.Parameter(\"age\",value = \"20\") self.set_parameters([self.age]) # 4 查询参数 def get_param(self): self.get_logger().info(\"---- Get ----\") params = self.get_parameters([\"name\",\"height\",\"age\"]) for param in params: self.get_logger().info(\"%s ---&gt; %s\" % (param.name, param.value)) # 5 修改参数 def update_param(self): self.get_logger().info(\"---- Change ---\") self.set_parameters([rclpy.Parameter(\"name\",value = \"lisi\")]) self.get_param() # 6 删除参数 def del_param(self): self.get_logger().info(\"---- Delete ---\") self.undeclare_parameter(\"age\") params = self.get_parameters([\"name\",\"height\"]) for param in params: self.get_logger().info(\"%s ---&gt; %s\" % (param.name, param.value)) def main(): rclpy.init() param_server = PythonParaServer() param_server.declare_param() param_server.get_param() param_server.update_param() param_server.del_param() rclpy.spin(param_server) rclpy.shutdown() if __name__ == \"__main__\": main() 编译：colcon build --packages-select python_para_ser 激活环境：. install/setup.bash 运行节点：ros2 run python_para_ser pythonParaSerNode pldz@pldz-pc:/mnt/hgfs/VMware/ROS2_DEMO/4_Chapter/code$ ros2 run python_para_ser pythonParaSerNode [INFO] [1683212289.084496335] [pythonParaSerNode]: ---- Get ---- [INFO] [1683212289.084918579] [pythonParaSerNode]: name ---&gt; zhangsan [INFO] [1683212289.085258809] [pythonParaSerNode]: height ---&gt; 1.88 [INFO] [1683212289.085559614] [pythonParaSerNode]: age ---&gt; 20 [INFO] [1683212289.085874466] [pythonParaSerNode]: ---- Change --- [INFO] [1683212289.086474845] [pythonParaSerNode]: ---- Get ---- [INFO] [1683212289.086867362] [pythonParaSerNode]: name ---&gt; lisi [INFO] [1683212289.087193515] [pythonParaSerNode]: height ---&gt; 1.88 [INFO] [1683212289.087519418] [pythonParaSerNode]: age ---&gt; 20 [INFO] [1683212289.087884144] [pythonParaSerNode]: ---- Delete --- [INFO] [1683212289.088266933] [pythonParaSerNode]: name ---&gt; lisi [INFO] [1683212289.088594118] [pythonParaSerNode]: height ---&gt; 1.88 4.3.2 创建Python节点参数客户端 创建功能包，包名为python_para_cli，节点名为pythonParaCliNode，依赖rclpy：ros2 pkg create python_para_cli --build-type ament_python --node-name pythonParaCliNode --dependencies rclpy 创建节点参数客户端，值得注意的是需要连接到服务端节点，然后进行参数的增删改查操作，值得注意的是节点参数的客户端在Python中没有被明确封装，但是节点参数底层是通过服务和话题实现的，因此调用原始的服务和话题实现(原来教程连接：https://www.bilibili.com/video/BV1LG411E7qT)： # 1. 导入包 import rclpy from rclpy.node import Node from rcl_interfaces.srv import ListParameters from rcl_interfaces.srv import GetParameters from rcl_interfaces.srv import SetParameters from rcl_interfaces.msg import ParameterType from rcl_interfaces.msg import Parameter from rcl_interfaces.msg import ParameterValue from ros2param.api import get_parameter_value # 2 创建客户节点 class PythonParaClient(Node): # 2.1 构造函数 def __init__(self): super().__init__('pythonParaCliNode') # 3 连接服务节点 def list_params(self): # 3.1 创建客户端； cli_list = self.create_client(ListParameters, '/pythonParaSerNode/list_parameters') # 3.2 等待服务连接； while not cli_list.wait_for_service(timeout_sec=1.0): self.get_logger().info('Waiting for connect ...') req = ListParameters.Request() future = cli_list.call_async(req) rclpy.spin_until_future_complete(self,future) return future.result() # 4 获得所有参数 def get_params(self,names): # 4.1 创建客户端 cli_get = self.create_client(GetParameters, '/pythonParaSerNode/get_parameters') # 4.2 等待服务连接 while not cli_get.wait_for_service(timeout_sec=1.0): self.get_logger().info('Waiting for connect ...') req = GetParameters.Request() req.names = names future = cli_get.call_async(req) rclpy.spin_until_future_complete(self,future) return future.result() # 5 更新参数服务值 def set_params(self): # 5.1 创建客户端 cli_set = self.create_client(SetParameters, '/pythonParaSerNode/set_parameters') # 5.2 等待服务连接 while not cli_set.wait_for_service(timeout_sec=1.0): self.get_logger().info('Waiting for connect ...') req = SetParameters.Request() p1 = Parameter() p1.name = \"name\" p1.value = get_parameter_value(string_value=\"zhangsan\") req.parameters = [p1] future = cli_set.call_async(req) rclpy.spin_until_future_complete(self,future) return future.result() def main(): rclpy.init() client = PythonParaClient() # 获取参数列表 client.get_logger().info(\"--------- List all parameters node ---------\") response = client.list_params() for name in response.result.names: client.get_logger().info(name) client.get_logger().info(\"--------- Get ---------\") names = [\"name\",\"height\"] response = client.get_params(names) print(response.values) client.get_logger().info(\"--------- Set ---------\") response = client.set_params() results = response.results response = client.get_params(names) print(response.values) rclpy.shutdown() if __name__ == \"__main__\": main() 编译：colcon build --packages-select python_para_cli 激活环境：. install/setup.bash 先运行服务端节点ros2 run python_para_ser pythonParaSerNode，然后运行客户端节点ros2 run python_para_cli pythonParaCliNode 4.4 ROS2节点参数小结 节点参数可删除的内容必须是未被声明的 客户端节点想修改服务节点的需要进行连接，连接成功之后才能进行增删改查"
  },"/ros2_basic/2023-02-04-3_1_ROS2%E6%9C%8D%E5%8A%A1%E9%80%9A%E8%AE%AF.html": {
    "title": "3 ROS2服务通讯基础",
    "keywords": "ROS2_BASIC",
    "url": "/ros2_basic/2023-02-04-3_1_ROS2%E6%9C%8D%E5%8A%A1%E9%80%9A%E8%AE%AF.html",
    "body": "3.1 服务通讯介绍 参考内容 Understanding services 服务通讯是ROS2的一种基于请求响应式的通讯方式，与之前的话题通讯不同的是服务通讯不是连续的数据流式的通讯，而是需要特定的触发才能收到回复的模式。 服务通讯可以是单个服务端和和单个客户端直接的通讯，一对一的模式 服务通讯也可以是单个服务端和多个客户端通讯，一对多的模式 3.2 ROS2服务通讯的基本流程 事实上，服务通讯和自定义的话题通讯的操作过程很类似，即将所需要利用到服务模块利用ament_camke工具编译成.c和.py的ROS2功能包，然后新建的功能包依赖这个服务功能包完成通讯。 3.2.1 创建ROS2服务通讯功能包的基本流程 创建ROS2功能包，功能包可以只用来作为存放自定义的msg/srv/action，不需要节点node的功能包，且--build-type必须是ament_camke ，因为目前来看，Python的自定义的消息或者服务也需要通过cmake编译出来再调用，功能包必须是下划线的推荐命名方法，而不是大小写的驼峰，否则会报错，如下所示： rosidl_adapter.parser.InvalidResourceName: 'xxxxx' is an invalid package name. It should have the pattern '^(?!.*__)(?!.*_$)[a-z][a-z0-9_]*$' 在ROS2功能包内创建srv文件夹，里面存放自定义的.srv消息文件，并且 .srv文件必须是大写开头的符合类的命名规则 配置packages.xml文件，都需要配置下面的内容(下面的配置项与.srv文件无关，是默认的固定配置) &lt;!-- 这一项是针对在srv文件中可能用到的其他依赖项，例如geomtry_msgs等等，如过没有用到就不添加 --&gt; &lt;depend&gt;其他的depend&lt;/depend&gt; &lt;!-- 下面三项是必须的 --&gt; &lt;build_depend&gt;rosidl_default_generators&lt;/build_depend&gt; &lt;exec_depend&gt;rosidl_default_runtime&lt;/exec_depend&gt; &lt;member_of_group&gt;rosidl_interface_packages&lt;/member_of_group&gt; 配置CMakeLists.txt文件,find_package和rosidl_generate_interfaces # 0. 是针对在srv文件中可能用到的其他依赖项，例如geomtry_msgs等等，则需要添加 # find_package(geometry_msgs REQUIRED) # 1. rosidl_default_generators是必须添加的内容 find_package(rosidl_default_generators REQUIRED) # 2. rosidl_generate_interfaces必须配置，里面添加srv文件位置 rosidl_generate_interfaces(${PROJECT_NAME} # 2.1 添加自定义的srv位置，例如存放在功能包的srv文件夹下的xxx.srv \"srv/xxx.srv\" # 2.2 可选，如果xxx.srv依赖了其他的内容,例如依赖了geometry_msgs DEPENDENCIES geometry_msgs ) 编译功能包:colcon build --packages-select &lt;功能包名&gt; 此时激活install目录下的setup.bash如. install/setup.bash，可以通过ros2 interface show &lt;功能包名称&gt;/srv/xxx.srv查看到xxx.srv内容，此时编译好的srv的.c文件存放在install/&lt;功能包名&gt;/include下，.py文件则存放在install/&lt;功能包名&gt;/local/ 3.2.2 创建ROS2服务通讯功能包示例 创建自定义消息功能包srv_demo，采用ament_cmake方式：ros2 pkg create srv_demo --build-type ament_cmake 在功能包内创建srv文件夹，其中存放AddInt.srv文件，需要利用到---符号作为分割，文件在---上面的内容作为请求体的参数，在---下面的内容作为响应体的参数，文件内容如下： int32 num1 int32 num2 --- int32 sum 此时的功能包内部的目录结构如下：tree -a pldz@pldz-pc:~/share/ROS2_DEMO/3_Chapter/code/srv_demo$ tree -a . ├── CMakeLists.txt ├── include │ └── srv_demo ├── package.xml ├── src └── srv └── AddInt.srv 配置packages.xml添加依赖项，由于AddInt.srv没有依赖任何的东西因此不需要添加其他的depend: &lt;?xml version=\"1.0\"?&gt; &lt;?xml-model href=\"http://download.ros.org/schema/package_format3.xsd\" schematypens=\"http://www.w3.org/2001/XMLSchema\"?&gt; &lt;package format=\"3\"&gt; &lt;name&gt;msg_demo&lt;/name&gt; &lt;version&gt;0.0.0&lt;/version&gt; &lt;description&gt;TODO: Package description&lt;/description&gt; &lt;maintainer email=\"pldz@R7000.com\"&gt;pldz&lt;/maintainer&gt; &lt;license&gt;TODO: License declaration&lt;/license&gt; &lt;buildtool_depend&gt;ament_cmake&lt;/buildtool_depend&gt; &lt;!-- 构建自定义功能包的的必须依赖项 --&gt; &lt;buildtool_depend&gt;rosidl_default_generators&lt;/buildtool_depend&gt; &lt;exec_depend&gt;rosidl_default_runtime&lt;/exec_depend&gt; &lt;member_of_group&gt;rosidl_interface_packages&lt;/member_of_group&gt; &lt;test_depend&gt;ament_lint_auto&lt;/test_depend&gt; &lt;test_depend&gt;ament_lint_common&lt;/test_depend&gt; &lt;export&gt; &lt;build_type&gt;ament_cmake&lt;/build_type&gt; &lt;/export&gt; &lt;/package&gt; 配置CMakeLists.txt文件，添加构建自定义AddInt.srv的依赖： cmake_minimum_required(VERSION 3.8) project(srv_demo) if(CMAKE_COMPILER_IS_GNUCXX OR CMAKE_CXX_COMPILER_ID MATCHES \"Clang\") add_compile_options(-Wall -Wextra -Wpedantic) endif() # find dependencies find_package(ament_cmake REQUIRED) # uncomment the following section in order to fill in # further dependencies manually. # find_package(&lt;dependency&gt; REQUIRED) # 1. 构建自定义功能包必须的依赖 find_package(rosidl_default_generators REQUIRED) # 2. 配置自定义的srv的位置 rosidl_generate_interfaces(${PROJECT_NAME} \"srv/AddInt.srv\" ) if(BUILD_TESTING) find_package(ament_lint_auto REQUIRED) # the following line skips the linter which checks for copyrights # comment the line when a copyright and license is added to all source files set(ament_cmake_copyright_FOUND TRUE) # the following line skips cpplint (only works in a git repo) # comment the line when this package is in a git repo and when # a copyright and license is added to all source files set(ament_cmake_cpplint_FOUND TRUE) ament_lint_auto_find_test_dependencies() endif() ament_package() 构建功能包：colcon build --packages-select srv_demo 查看自定义的消息：激活环境：. install/setup.bash ，查看自定义消息ros2 interface show srv_demo/srv/AddInt pldz@pldz-pc:~/share/ROS2_DEMO/3_Chapter/code$ colcon build --packages-select srv_demo Starting &gt;&gt;&gt; srv_demo Finished &lt;&lt;&lt; srv_demo [12.2s] Summary: 1 package finished [12.5s] pldz@pldz-pc:~/share/ROS2_DEMO/3_Chapter/code$ . install/setup.bash pldz@pldz-pc:~/share/ROS2_DEMO/3_Chapter/code$ ros2 interface show srv_demo/srv/AddInt int32 num1 int32 num2 --- int32 sum 查看instll下面的文件：其中.c的class文件在install/&lt;功能包名&gt;/include/&lt;功能包名&gt;/&lt;功能包名&gt;/msg/**，.py在install/&lt;功能包名&gt;/local/lib/python3.10/dist-packages/&lt;功能包名&gt;/msg/**，后续Vscode可以通过配置settings.json添加提示 3.3 使用C/C++实现ROS2服务通讯 这里直接使用3.2.2创建的srv_demo服务功能包进行ROS2 C/C++的服务通讯的实现 参考内容： Writing a simple service and client (C++) 2.3.3_服务通信_C++实现_01框架搭建 ROS2探索（三）service 3.3.1 创建C/C++服务通讯服务端功能包并编写节点文件 创建功能包，其中功能包名称为cpp_srv_server，节点名为cppSrvServerNode：ros2 pkg create cpp_srv_server --build-type ament_cmake --node-name cppSrvServerNode 配置Vscode环境，在工作空间创建.vscode文件夹，并加入settings.json文件，添加ROS2的include环境和当前工作空间的install文件夹下的srv_demo功能包的include路径： { \"C_Cpp.default.includePath\": [ \"/opt/ros/humble/include/**\", \"./install/srv_demo/include/**\" ], } 编写服务端节点文件，主要包括导入包，创建服务节点，实现回调函数： // 1. 调用自定义的服务文件 // 1.1 rclcpp和srv_demo两个功能包的头文件 // 如果有vscode的下划线提示，说明是settings.json没有配置好 #include \"rclcpp/rclcpp.hpp\" #include \"srv_demo/srv/add_int.hpp\" // 1.2. 调用功能包下的自定义的服务，其中自定义的服务名已经变成了一个类名 using srv_demo::srv::AddInt; // std_bind的占位符 using std::placeholders::_1; using std::placeholders::_2; // 2.定义节点类； class CppSrvServer: public rclcpp::Node{ public: // 2.1 构造函数，其中节点名直接赋予cppSrvServerNode CppSrvServer():Node(\"cppSrvServerNode\"){ // 2.2 创建服务端 server_ = this-&gt;create_service&lt;AddInt&gt;(\"mySrvName\",std::bind(&amp;CppSrvServer::addIntFunc, this, _1, _2)); RCLCPP_INFO(this-&gt;get_logger(),\"Server is starting ...\"); } private: // 3. 服务端的回调函数实现，其中参数的写法区分主要在于类型，参数数量包括请求体req和响应体rsp void addIntFunc(const AddInt::Request::SharedPtr req, const AddInt::Response::SharedPtr rsp) { rsp-&gt;sum = req-&gt;num1 + req-&gt;num2; RCLCPP_INFO(this-&gt;get_logger(),\"request body :(%d,%d), response is :%d\", req-&gt;num1, req-&gt;num2, rsp-&gt;sum); } // 4 服务的声明 rclcpp::Service&lt;AddInt&gt;::SharedPtr server_; }; int main(int argc, char const *argv[]) { rclcpp::init(argc,argv); auto server_ = std::make_shared&lt;CppSrvServer&gt;(); rclcpp::spin(server_); rclcpp::shutdown(); return 0; } 3.3.2 配置C/C++服务通讯服务端功能包 配置packages.xml文件，添加依赖项有rclcpp用于构建节点，和srv_demo用于构建AddInt： &lt;?xml version=\"1.0\"?&gt; &lt;?xml-model href=\"http://download.ros.org/schema/package_format3.xsd\" schematypens=\"http://www.w3.org/2001/XMLSchema\"?&gt; &lt;package format=\"3\"&gt; &lt;name&gt;cpp_srv_server&lt;/name&gt; &lt;version&gt;0.0.0&lt;/version&gt; &lt;description&gt;TODO: Package description&lt;/description&gt; &lt;maintainer email=\"pldz@R7000.com\"&gt;pldz&lt;/maintainer&gt; &lt;license&gt;TODO: License declaration&lt;/license&gt; &lt;buildtool_depend&gt;ament_cmake&lt;/buildtool_depend&gt; &lt;test_depend&gt;ament_lint_auto&lt;/test_depend&gt; &lt;test_depend&gt;ament_lint_common&lt;/test_depend&gt; &lt;!-- 依赖rclcpp创建节点和自定义的服务功能包 --&gt; &lt;depend&gt;rclcpp&lt;/depend&gt; &lt;depend&gt;srv_demo&lt;/depend&gt; &lt;export&gt; &lt;build_type&gt;ament_cmake&lt;/build_type&gt; &lt;/export&gt; &lt;/package&gt; 配置CMakeLists.txt： cmake_minimum_required(VERSION 3.8) project(cpp_srv_server) if(CMAKE_COMPILER_IS_GNUCXX OR CMAKE_CXX_COMPILER_ID MATCHES \"Clang\") add_compile_options(-Wall -Wextra -Wpedantic) endif() # find dependencies find_package(ament_cmake REQUIRED) # uncomment the following section in order to fill in # further dependencies manually. # find_package(&lt;dependency&gt; REQUIRED) # 1. 列出依赖项的包 find_package(rclcpp REQUIRED) find_package(srv_demo REQUIRED) # 2. 默认是已经创建了构建节点的文件配置 add_executable(cppSrvServerNode src/cppSrvServerNode.cpp) # 3. 默认已经包括&lt;INSTALL_INTERFACE&gt;的路径也不用更改 target_include_directories(cppSrvServerNode PUBLIC $&lt;BUILD_INTERFACE:${CMAKE_CURRENT_SOURCE_DIR}/include&gt; $&lt;INSTALL_INTERFACE:include&gt;) target_compile_features(cppSrvServerNode PUBLIC c_std_99 cxx_std_17) # Require C99 and C++17 # 4. ament工具构建节点的依赖配置 ament_target_dependencies( cppSrvServerNode rclcpp srv_demo ) # 5. Install配置，默认ros2 run &lt;包名&gt;的配置 install(TARGETS cppSrvServerNode DESTINATION lib/${PROJECT_NAME}) if(BUILD_TESTING) find_package(ament_lint_auto REQUIRED) # the following line skips the linter which checks for copyrights # comment the line when a copyright and license is added to all source files set(ament_cmake_copyright_FOUND TRUE) # the following line skips cpplint (only works in a git repo) # comment the line when this package is in a git repo and when # a copyright and license is added to all source files set(ament_cmake_cpplint_FOUND TRUE) ament_lint_auto_find_test_dependencies() endif() # 6. 生成包的环境 ament_package() 3.3.3 编译并运行C/C++服务通讯服务端 编译： colcon build --packages-select cpp_srv_server 激活环境：. install/setup.bash 运行：ros2 run cpp_srv_server cppSrvServerNode pldz@pldz-pc:~/share/ROS2_DEMO/3_Chapter/code$ colcon build --packages-select cpp_srv_server Starting &gt;&gt;&gt; cpp_srv_server Finished &lt;&lt;&lt; cpp_srv_server [20.6s] Summary: 1 package finished [21.0s] pldz@pldz-pc:~/share/ROS2_DEMO/3_Chapter/code$ . install/setup.bash pldz@pldz-pc:~/share/ROS2_DEMO/3_Chapter/code$ ros2 run cpp_srv_server cppSrvServerNode [INFO] [1683125184.734934447] [cppSrvServerNode]: Server is starting ... ^C[INFO] [1683125186.240946812] [rclcpp]: signal_handler(signum=2) 3.3.4 创建C/C++服务通讯客户端功能包并编写节点文件 创建功能包，功能包名为cpp_srv_client，节点名称为cppSrvClientNode，依赖rclcpp和srv_demo：ros2 pkg create cpp_srv_client --build-type ament_cmake --node-name cppSrvClientNode --dependencies rclcpp srv_demo 编写客户端节点，注意在此过程中需要和 服务端的连接进行判断，以及发送的请求是否能够收到返回值的用法的操作： // 1. 调用自定义的服务文件 // 1.1 rclcpp和srv_demo两个功能包的头文件 #include \"rclcpp/rclcpp.hpp\" #include \"srv_demo/srv/add_int.hpp\" // 1.2. 调用功能包下的自定义的服务，其中自定义的服务名已经变成了一个类名 using srv_demo::srv::AddInt; // 时间函数用于持续访问服务端 using namespace std::chrono_literals; // 2.定义节点类； class CppSrvClient: public rclcpp::Node{ public: CppSrvClient():Node(\"cppSrvClientNode\") { // 2.1 创建客户端,并绑定服务通讯名称为mySrvName client_ = this-&gt;create_client&lt;AddInt&gt;(\"mySrvName\"); RCLCPP_INFO(this-&gt;get_logger(),\"Client is starting ...\"); } // 2.2 等待与服务的连接 bool connect_server(){ while (!client_-&gt;wait_for_service(1s)) { if (!rclcpp::ok()) { RCLCPP_INFO(rclcpp::get_logger(\"rclcpp\"),\"Interrupted while waiting for the service. Exiting.\"); return false; } RCLCPP_INFO(this-&gt;get_logger(),\"service not available, waiting again...\"); } return true; } // 2.3 客户端发送请求； rclcpp::Client&lt;srv_demo::srv::AddInt&gt;::FutureAndRequestId send_request(int32_t num1, int32_t num2) { auto request = std::make_shared&lt;AddInt::Request&gt;(); request-&gt;num1 = num1; request-&gt;num2 = num2; // 2.3.1 发送请求 auto response = client_-&gt;async_send_request(request); return response; } private: // 2.4 服务通讯客户端的声明 rclcpp::Client&lt;AddInt&gt;::SharedPtr client_; }; int main(int argc, char ** argv) { // 3. 初始化ROS2客户端 rclcpp::init(argc,argv); // 3.1 创建对象指针并调用其功能； auto cppSrvClientNode = std::make_shared&lt;CppSrvClient&gt;(); // 3.2 连接客户端 bool flag = cppSrvClientNode-&gt;connect_server(); if (!flag) { RCLCPP_INFO(rclcpp::get_logger(\"rclcpp\"),\"Connect failed! \"); return 0; } // 3.3 发送请求并等待响应 auto response = cppSrvClientNode-&gt;send_request(100,200); // 3.4 节点处理响应 if (rclcpp::spin_until_future_complete(cppSrvClientNode,response) == rclcpp::FutureReturnCode::SUCCESS) { RCLCPP_INFO(cppSrvClientNode-&gt;get_logger(),\"The response is :%d!\", response.get()-&gt;sum); } else { RCLCPP_INFO(cppSrvClientNode-&gt;get_logger(),\"Request error\"); } rclcpp::shutdown(); return 0; } 3.3.5 编译并运行C/C++服务通讯客户端节点 由于在创建包的过程中已经指明了所有依赖项，不需要进行额外的配置，直接编译运行即可：colcon build --packages-select cpp_srv_client 激活环境并运行节点 3.4 使用Python实现ROS2服务通讯 参考内容 Writing a simple service and client (Python) 2.3.4_服务通信_Python实现_01框架搭建 3.4.1 创建Python服务通讯服务端功能包并编写节点文件 创建功能包，包名为python_srv_server，节点名为pythonSrvServerNode：ros2 pkg create python_srv_server --build-type ament_python --node-name pythonSrvServerNode 配置Vscode，主要添加功能包的提示环境，编辑settings.json： { \"C_Cpp.default.includePath\": [ \"/opt/ros/humble/include/**\", \"./install/srv_demo/include/**\" ], \"python.analysis.include\": [ \"/opt/ros/humble/local/lib/python3.10/dist-packages/**\", \"./install/srv_demo/local/lib/python3.10/dist-packages/**\" ] } 编写Python服务端节点文件： import rclpy from rclpy.node import Node # 1. 导入包，其中的类名等于服务文件名称 from srv_demo.srv import AddInt # 2. 定义服务端节点 class PythonSrvServer(Node): def __init__(self): super().__init__('pythonSrvServerNode') # 2.1 创建服务端 self.srver_ = self.create_service(AddInt, 'mySrvName', self.addIntFunc) self.get_logger().info(\"Server is starting ...\") # 2.2 服务端的处理回调函数 def addIntFunc(self, request:AddInt, response:AddInt): response.sum = request.num1 + request.num2 self.get_logger().info('The request is :{} {},Response is :{}'.format(request.num1, request.num2, response.sum)) return response def main(): rclpy.init() pythonSrvServerNode = PythonSrvServer() rclpy.spin(pythonSrvServerNode) rclpy.shutdown() if __name__ == '__main__': main() 3.4.2 配置Python服务通讯服务端功能包 配置packages.xml增加rclpy和srv_demo两个依赖项，注意Python本身是可执行文件，因此它的为&lt;exec_depend&gt;与C/C++的&lt;depend&gt;关键字不同： &lt;?xml version=\"1.0\"?&gt; &lt;?xml-model href=\"http://download.ros.org/schema/package_format3.xsd\" schematypens=\"http://www.w3.org/2001/XMLSchema\"?&gt; &lt;package format=\"3\"&gt; &lt;name&gt;python_srv_server&lt;/name&gt; &lt;version&gt;0.0.0&lt;/version&gt; &lt;description&gt;TODO: Package description&lt;/description&gt; &lt;maintainer email=\"pldz@R7000.com\"&gt;pldz&lt;/maintainer&gt; &lt;license&gt;TODO: License declaration&lt;/license&gt; &lt;!-- 添加依赖项的包，注意是exec_depend --&gt; &lt;exec_depend&gt;rclpy&lt;/exec_depend&gt; &lt;exec_depend&gt;srv_demo&lt;/exec_depend&gt; &lt;test_depend&gt;ament_copyright&lt;/test_depend&gt; &lt;test_depend&gt;ament_flake8&lt;/test_depend&gt; &lt;test_depend&gt;ament_pep257&lt;/test_depend&gt; &lt;test_depend&gt;python3-pytest&lt;/test_depend&gt; &lt;export&gt; &lt;build_type&gt;ament_python&lt;/build_type&gt; &lt;/export&gt; &lt;/package&gt; 配置setup.py文件，事实上，我们已经创建包的时候已经指定了节点名，其实应该是不用配置生成节点的main入口的： from setuptools import setup package_name = 'python_srv_server' setup( name=package_name, version='0.0.0', packages=[package_name], data_files=[ ('share/ament_index/resource_index/packages', ['resource/' + package_name]), ('share/' + package_name, ['package.xml']), ], install_requires=['setuptools'], zip_safe=True, maintainer='pldz', maintainer_email='pldz@R7000.com', description='TODO: Package description', license='TODO: License declaration', tests_require=['pytest'], # 配置节点main函数入口 entry_points={ 'console_scripts': [ 'pythonSrvServerNode = python_srv_server.pythonSrvServerNode:main' ], }, ) 3.4.3 编译并运行Python服务通讯服务端功能包 编译：colcon build --packages-select python_srv_server 激活环境：. install/setup.bash 运行节点：ros2 run python_srv_server pythonSrvServerNode pldz@pldz-pc:~/share/ROS2_DEMO/3_Chapter/code$ colcon build --packages-select python_srv_server Starting &gt;&gt;&gt; python_srv_server --- stderr: python_srv_server /usr/lib/python3/dist-packages/setuptools/command/install.py:34: SetuptoolsDeprecationWarning: setup.py install is deprecated. Use build and pip and other standards-based tools. warnings.warn( --- Finished &lt;&lt;&lt; python_srv_server [2.18s] Summary: 1 package finished [2.71s] 1 package had stderr output: python_srv_server pldz@pldz-pc:~/share/ROS2_DEMO/3_Chapter/code$ . install/setup.bash pldz@pldz-pc:~/share/ROS2_DEMO/3_Chapter/code$ ros2 run python_srv_server pythonSrvServerNode [INFO] [1683157866.794236460] [pythonSrvServerNode]: Server is starting ... 3.3.4 创建Python服务通讯客户端功能包并编写节点文件 创建Python功能包时，包名为python_srv_client，节点名为pythonSrvClientNode，直接指定依赖项rclpy和srv_demo：ros2 pkg create python_srv_client --build-type ament_python --node-name pythonSrvClientNode --dependencies rclpy srv_demo 编写节点：主要是统一节点的订阅话题，异步接收返回的结果 import sys import rclpy from rclpy.node import Node # 1. 导入包 from srv_demo.srv import AddInt # 2.定义客户端节点 class pythonSrvClient(Node): def __init__(self): # 2.1 继承node节点，节点名为pythonSrvClientNode super().__init__('pythonSrvClientNode') # 2.2 创建客户端 self.client_ = self.create_client(AddInt, 'mySrvName') # 2.3 等待连接 self.wait_for_connect() # 3. 实现等待函数 def wait_for_connect(self): while not self.client_.wait_for_service(timeout_sec=1.0): self.get_logger().info('Waiting for connect ...') # 4. 实现发送请求函数 def send_request(self, num1, num2): request = AddInt.Request() request.num1 = num1 request.num2 = num2 self.future = self.client_.call_async(request) def main(): rclpy.init() # 5.创建客户端节点 pythonSrvClientNode = pythonSrvClient() pythonSrvClientNode.send_request(200,300) # 6. 等待响应 rclpy.spin_until_future_complete(pythonSrvClientNode,pythonSrvClientNode.future) try: response = pythonSrvClientNode.future.result() except Exception as e: pythonSrvClientNode.get_logger().info('Request error {}'.format(e)) else: pythonSrvClientNode.get_logger().info( 'Response is {}'.format(response.sum)) rclpy.shutdown() if __name__ == '__main__': main() 3.4.5 编译并运行Python服务通讯客户端节点 由于指定了依赖项，直接编译即可: colcon build --packages-select python_srv_client 激活环境: . install/setup.bash 运行所有节点： 3.5 服务通讯小结 创建功能包时，如果能够直接指定节点名和依赖项，可以省去很大部分的配置工作 C/C++手动配置功能包时，packages.xml配置依赖项，CMakeLists.txt配置编译的内容，包括find_package；add_executable；target_include_directories；ament_target_dependencies；install；ament_package这六个部分 Python手动配置功能包时，packages.xml配置可执行的依赖项exec_depend而不是depend,并且在setup.py中主要配置节点的main函数入口 服务通讯的导入本质是创建一个C/C++的功能包，将里面的自定义消息编译成可以使用的.c和.py文件，值得注意的是，生成好的中间文件是存放在 工作空间的install文件夹下，如果这个这个工作空间的install找不到或者不是一个，那是需要再进一步的手动配置的 服务通讯的请求响应是这里是异步实现的，即客户端需要等待服务端返回的结果，才能判断是否完成接收"
  },"/ros2_basic/2023-02-03-2_2_ROS2%E8%AF%9D%E9%A2%98%E9%80%9A%E8%AE%AF%E6%8F%90%E5%8D%87.html": {
    "title": "2 ROS2话题通讯 - 话题通讯进阶",
    "keywords": "ROS2_BASIC",
    "url": "/ros2_basic/2023-02-03-2_2_ROS2%E8%AF%9D%E9%A2%98%E9%80%9A%E8%AE%AF%E6%8F%90%E5%8D%87.html",
    "body": "2.5 自定义话题通讯 参考内容 Creating custom msg and srv files 2.2.4_话题通信_自定义接口消息_接口文件 2.5.1 自定义话题通讯的一般流程 构建自定义话题其实就是利用ament_cmake工具构建出该自定义话题的.c和.py文件，编译好的自定义话题，也就可以和std_msgs一样在创建包的时候，手动添加进去，后续即可不用再配置packages.xml和CMakeLists.txt 创建ROS2功能包，功能包可以只用来作为存放自定义的msg/srv，不需要节点node的功能包，且--build-type必须是ament_camke ，因为目前来看，Python的自定义的消息或者服务也需要通过cmake编译出来再调用，功能包必须是下划线的推荐命名方法，而不是大小写的驼峰，否则会报错，如下所示： --- stderr: msgDemoError CMake Error at /opt/ros/humble/share/rosidl_adapter/cmake/rosidl_adapt_interfaces.cmake:59 (message): execute_process(/usr/bin/python3.10 -m rosidl_adapter --package-name msgDemoError --arguments-file /mnt/hgfs/VMware/ROS2_DEMO/2_Chapter/code/build/msgDemoError/rosidl_adapter__arguments__msgDemoError.json --output-dir /mnt/hgfs/VMware/ROS2_DEMO/2_Chapter/code/build/msgDemoError/rosidl_adapter/msgDemoError --output-file /mnt/hgfs/VMware/ROS2_DEMO/2_Chapter/code/build/msgDemoError/rosidl_adapter/msgDemoError.idls) returned error code 1: Error processing 'String name' of 'msgDemoError/Student': ''msgDemoError' is an invalid package name. It should have the pattern '^(?!.*__)(?!.*_$)[a-z][a-z0-9_]*$'' Traceback (most recent call last): File \"/usr/lib/python3.10/runpy.py\", line 196, in _run_module_as_main return _run_code(code, main_globals, None, File \"/usr/lib/python3.10/runpy.py\", line 86, in _run_code exec(code, run_globals) File \"/opt/ros/humble/local/lib/python3.10/dist-packages/rosidl_adapter/__main__.py\", line 19, in &lt;module&gt; sys.exit(main()) File \"/opt/ros/humble/local/lib/python3.10/dist-packages/rosidl_adapter/main.py\", line 53, in main abs_idl_file = convert_to_idl( File \"/opt/ros/humble/local/lib/python3.10/dist-packages/rosidl_adapter/__init__.py\", line 19, in convert_to_idl return convert_msg_to_idl( File \"/opt/ros/humble/local/lib/python3.10/dist-packages/rosidl_adapter/msg/__init__.py\", line 28, in convert_msg_to_idl msg = parse_message_string(package_name, input_file.stem, content) File \"/opt/ros/humble/local/lib/python3.10/dist-packages/rosidl_adapter/parser.py\", line 520, in parse_message_string Type(type_string, context_package_name=pkg_name), File \"/opt/ros/humble/local/lib/python3.10/dist-packages/rosidl_adapter/parser.py\", line 277, in __init__ super(Type, self).__init__( File \"/opt/ros/humble/local/lib/python3.10/dist-packages/rosidl_adapter/parser.py\", line 201, in __init__ raise InvalidResourceName( rosidl_adapter.parser.InvalidResourceName: 'msgDemoError' is an invalid package name. It should have the pattern '^(?!.*__)(?!.*_$)[a-z][a-z0-9_]*$' Call Stack (most recent call first): /opt/ros/humble/share/rosidl_cmake/cmake/rosidl_generate_interfaces.cmake:130 (rosidl_adapt_interfaces) CMakeLists.txt:16 (rosidl_generate_interfaces) --- Failed &lt;&lt;&lt; msgDemoError [1.53s, exited with code 1] 在ROS2功能包内创建msg文件夹，里面存放自定义的.msg消息文件，并且 .msg文件必须是大写开头的符合类的命名规则 配置packages.xml文件，都需要配置下面的内容(下面的配置项与.msg文件无关，是默认的固定配置) &lt;!-- 这一项是针对在msg中可能用到的其他依赖项，例如geomtry_msgs等等，如过没有用到就不添加 --&gt; &lt;depend&gt;其他的depend&lt;/depend&gt; &lt;!-- 下面三项是必须的 --&gt; &lt;build_depend&gt;rosidl_default_generators&lt;/build_depend&gt; &lt;exec_depend&gt;rosidl_default_runtime&lt;/exec_depend&gt; &lt;member_of_group&gt;rosidl_interface_packages&lt;/member_of_group&gt; 配置CMakeLists.txt文件,find_package和rosidl_generate_interfaces # 0. 是针对在msg中可能用到的其他依赖项，例如geomtry_msgs等等，则需要添加 # find_package(geometry_msgs REQUIRED) # 1. rosidl_default_generators是必须添加的内容 find_package(rosidl_default_generators REQUIRED) # 2. rosidl_generate_interfaces必须配置，里面添加msg文件位置 rosidl_generate_interfaces(${PROJECT_NAME} # 2.1 添加自定义的msg位置，例如存放在功能包的msg文件夹下的xxx.msg \"msg/xxx.msg\" # 2.2 可选，如果xxx.msg依赖了其他的内容,例如依赖了geometry_msgs DEPENDENCIES geometry_msgs ) 编译功能包:colcon build --packages-select &lt;功能包名&gt; 此时激活install目录下的setup.bash如. install/setup.bash，可以通过ros2 interface show &lt;功能包名称&gt;/msg/xxx.msg查看到xxx.msg内容，此时编译好的msg的.c文件存放在install/&lt;功能包名&gt;/include下，.py文件则存放在install/&lt;功能包名&gt;/local/ 2.5.2 创建自定义话题消息简单例子 创建自定义消息功能包msg_demo，采用ament_cmake方式：ros2 pkg create msg_demo --build-type ament_cmake 在功能包内创建msg文件夹，其中存放Demo.msg文件，文件内容如下：其中还依赖geometry_msgs geometry_msgs/Point center float64 radius 此时的功能包内部的目录结构如下：tree -a pldz@pldz-pc:~/share/ROS2_DEMO/2_Chapter/code/msg_demo$ tree -a . ├── CMakeLists.txt ├── include │ └── msg_demo ├── msg │ └── Demo.msg ├── package.xml └── src 4 directories, 3 files 配置packages.xml添加依赖项，特别的是该Demo.msg还需依赖gemotry_msgs: &lt;?xml version=\"1.0\"?&gt; &lt;?xml-model href=\"http://download.ros.org/schema/package_format3.xsd\" schematypens=\"http://www.w3.org/2001/XMLSchema\"?&gt; &lt;package format=\"3\"&gt; &lt;name&gt;msg_demo&lt;/name&gt; &lt;version&gt;0.0.0&lt;/version&gt; &lt;description&gt;TODO: Package description&lt;/description&gt; &lt;maintainer email=\"pldz@R7000.com\"&gt;pldz&lt;/maintainer&gt; &lt;license&gt;TODO: License declaration&lt;/license&gt; &lt;buildtool_depend&gt;ament_cmake&lt;/buildtool_depend&gt; &lt;!-- 自定义Demo.msg中依赖geometry_msgs所以添加到depend --&gt; &lt;depend&gt;geometry_msgs&lt;/depend&gt; &lt;!-- 构建自定义msg的必须依赖项 --&gt; &lt;buildtool_depend&gt;rosidl_default_generators&lt;/buildtool_depend&gt; &lt;exec_depend&gt;rosidl_default_runtime&lt;/exec_depend&gt; &lt;member_of_group&gt;rosidl_interface_packages&lt;/member_of_group&gt; &lt;test_depend&gt;ament_lint_auto&lt;/test_depend&gt; &lt;test_depend&gt;ament_lint_common&lt;/test_depend&gt; &lt;export&gt; &lt;build_type&gt;ament_cmake&lt;/build_type&gt; &lt;/export&gt; &lt;/package&gt; 配置CMakeLists.txt文件，添加构建自定义Demo.msg的依赖： cmake_minimum_required(VERSION 3.8) project(msg_demo) if(CMAKE_COMPILER_IS_GNUCXX OR CMAKE_CXX_COMPILER_ID MATCHES \"Clang\") add_compile_options(-Wall -Wextra -Wpedantic) endif() # find dependencies find_package(ament_cmake REQUIRED) # uncomment the following section in order to fill in # further dependencies manually. # find_package(&lt;dependency&gt; REQUIRED) # 1. 自定义的Demo.msg依赖geometry_msgs find_package(geometry_msgs REQUIRED) # 2. 必须添加的构建自定义包辅助包的位置 find_package(rosidl_default_generators REQUIRED) # 3. 构建自定义msg rosidl_generate_interfaces(${PROJECT_NAME} \"msg/Demo.msg\" # Demo.msg的位置 DEPENDENCIES geometry_msgs # 创建Demo.msg需要的依赖 ) if(BUILD_TESTING) find_package(ament_lint_auto REQUIRED) # the following line skips the linter which checks for copyrights # comment the line when a copyright and license is added to all source files set(ament_cmake_copyright_FOUND TRUE) # the following line skips cpplint (only works in a git repo) # comment the line when this package is in a git repo and when # a copyright and license is added to all source files set(ament_cmake_cpplint_FOUND TRUE) ament_lint_auto_find_test_dependencies() endif() ament_package() 构建功能包：colcon build --packages-select msg_demo 查看自定义的消息：激活环境：. install/setup.bash ，查看自定义消息ros2 interface show msg_demo/msg/Demo pldz@pldz-pc:~/share/ROS2_DEMO/2_Chapter/code$ colcon build --packages-select msg_demo Starting &gt;&gt;&gt; msg_demo Finished &lt;&lt;&lt; msg_demo [10.4s] Summary: 1 package finished [10.7s] pldz@pldz-pc:~/share/ROS2_DEMO/2_Chapter/code$ . install/setup.bash pldz@pldz-pc:~/share/ROS2_DEMO/2_Chapter/code$ ros2 interface show msg_demo/msg/Demo geometry_msgs/Point center float64 x float64 y float64 z float64 radius 查看instll下面的文件：其中.c的class文件在install/&lt;功能包名&gt;/include/&lt;功能包名&gt;/&lt;功能包名&gt;/msg/**，.py在install/&lt;功能包名&gt;/local/lib/python3.10/dist-packages/&lt;功能包名&gt;/msg/** 2.5.3 快速创建C/C++和Python自定义话题通讯的Student.msg 新建功能包：ros2 pkg create student_msg --build-type ament_cmake 创建msg文件夹和Student.msg文件，写入如下内容: string name int32 exam float64 score 不需要其他依赖项，配置packages.xml添加下面三项即可： &lt;build_depend&gt;rosidl_default_generators&lt;/build_depend&gt; &lt;exec_depend&gt;rosidl_default_runtime&lt;/exec_depend&gt; &lt;member_of_group&gt;rosidl_interface_packages&lt;/member_of_group&gt; 配置CMakeLists.txt： find_package(rosidl_default_generators REQUIRED) rosidl_generate_interfaces(${PROJECT_NAME} \"msg/Student.msg\" ) 快速构建：colcon build --packages-select student_msg: pldz@pldz-pc:~/share/ROS2_DEMO/2_Chapter/code$ colcon build --packages-select student_msg Starting &gt;&gt;&gt; student_msg Finished &lt;&lt;&lt; student_msg [8.93s] Summary: 1 package finished [9.21s] 2.6 使用C/C++实现自定义话题通讯 2.6.1 创建C/C++自定义话题发布方功能包并编写节点文件 创建ROS2功能包,这里为了省的创建node文件直接指定了cpp_idl_pub，指令如下：ros2 pkg create cpp_idl_pub --build-type ament_cmake --node-name cppIdlPubNode， 配置Vscode：配置Vscode的settings.json： { \"C_Cpp.default.includePath\": [ \"/opt/ros/humble/include/**\", \"./install/student_msg/include/**\" ], \"python.analysis.extraPaths\": [ \"/opt/ros/humble/local/lib/python3.10/dist-packages/\" ], } 编写自定义节点文件cppIdlPubNode.cpp： #include \"rclcpp/rclcpp.hpp\" // 1. 添加自定义消息头文件，如果vscode出现下划线警告，则需要配置settings.json添加include路径 #include \"student_msg/msg/student.hpp\" // C++14中的时间库 using namespace std::chrono_literals; // 2. 引入Student.msg生成的Student类 using student_msg::msg::Student; class CppIdlMsgPub: public rclcpp::Node { public: /* 3. ROS2节点的构造函数，其中包括一个node对象（初始化时候没有给出节点的名称）， * 和属性exam_（初始化为0,类型为size_t)，以及属性socre_（类型为double_t初始值为60.0） */ CppIdlMsgPub(const char* nodeName):Node(nodeName), exam_(0), score_(60.0) { // 4. 创建发布者,参数分别为话题名称myStudent，和发布队列的长队为10 publisher_ = this-&gt;create_publisher&lt;Student&gt;(\"myStudent\", 10); // 5. 创建定时器，设置发布的频率，并绑定定时执行的事件，这里给到的是CppIdlMsgPub类的函数 timer_ = this-&gt;create_wall_timer(500ms, std::bind(&amp;CppIdlMsgPub::timer_callback, this)); } private: // 6. 定义回调函数 void timer_callback() { Student stu = Student(); // 6.1 姓名zhangsan stu.name = \"zhangsan\"; // 6.2 考试次数递增 stu.exam = exam_++; // 6.3 分数一直递增 stu.score = score_; score_ += 0.1; RCLCPP_INFO(this-&gt;get_logger(), \"Student: '%s', exam time: %d, socre is : %f\", stu.name.c_str(),stu.exam,stu.score); publisher_-&gt;publish(stu); } // 5. 计时器、发布者和计数器字段的声明 rclcpp::TimerBase::SharedPtr timer_; rclcpp::Publisher&lt;Student&gt;::SharedPtr publisher_; size_t exam_; double_t score_; }; int main(int argc, char * argv[]) { rclcpp::init(argc, argv); // 创建节点，给出构造的节点名为CppIdlMsgPubNode rclcpp::spin(std::make_shared&lt;CppIdlMsgPub&gt;(\"CppIdlMsgPubNode\")); rclcpp::shutdown(); return 0; } 2.6.2 配置C/C++自定义话题发布方功能包 配置packages.xml文件，添加依赖项有rclcpp用于构建节点，和student_msg用于构建Student.msg： &lt;?xml version=\"1.0\"?&gt; &lt;?xml-model href=\"http://download.ros.org/schema/package_format3.xsd\" schematypens=\"http://www.w3.org/2001/XMLSchema\"?&gt; &lt;package format=\"3\"&gt; &lt;name&gt;cpp_idl_pub&lt;/name&gt; &lt;version&gt;0.0.0&lt;/version&gt; &lt;description&gt;TODO: Package description&lt;/description&gt; &lt;maintainer email=\"pldz@R7000.com\"&gt;pldz&lt;/maintainer&gt; &lt;license&gt;TODO: License declaration&lt;/license&gt; &lt;buildtool_depend&gt;ament_cmake&lt;/buildtool_depend&gt; &lt;!-- 添加依赖项 --&gt; &lt;depend&gt;rclcpp&lt;/depend&gt; &lt;depend&gt;student_msg&lt;/depend&gt; &lt;test_depend&gt;ament_lint_auto&lt;/test_depend&gt; &lt;test_depend&gt;ament_lint_common&lt;/test_depend&gt; &lt;export&gt; &lt;build_type&gt;ament_cmake&lt;/build_type&gt; &lt;/export&gt; &lt;/package&gt; 配置CMakeLists.txt： cmake_minimum_required(VERSION 3.8) project(cpp_idl_pub) if(CMAKE_COMPILER_IS_GNUCXX OR CMAKE_CXX_COMPILER_ID MATCHES \"Clang\") add_compile_options(-Wall -Wextra -Wpedantic) endif() # find dependencies find_package(ament_cmake REQUIRED) # 1. 添加依赖项 find_package(rclcpp REQUIRED) find_package(student_msg REQUIRED) # uncomment the following section in order to fill in # further dependencies manually. # find_package(&lt;dependency&gt; REQUIRED) # 2. 默认是已经创建了构建节点的文件配置 add_executable(cppIdlPubNode src/cppIdlPubNode.cpp) # 3. 默认已经包括&lt;INSTALL_INTERFACE&gt;的路径也不用更改 target_include_directories(cppIdlPubNode PUBLIC $&lt;BUILD_INTERFACE:${CMAKE_CURRENT_SOURCE_DIR}/include&gt; $&lt;INSTALL_INTERFACE:include&gt;) # 4. ament工具构建节点的依赖配置 ament_target_dependencies( cppIdlPubNode rclcpp student_msg ) target_compile_features(cppIdlPubNode PUBLIC c_std_99 cxx_std_17) # Require C99 and C++17 # 5. Install配置，默认ros2 run &lt;包名&gt;的配置 install(TARGETS cppIdlPubNode DESTINATION lib/${PROJECT_NAME}) if(BUILD_TESTING) find_package(ament_lint_auto REQUIRED) # the following line skips the linter which checks for copyrights # comment the line when a copyright and license is added to all source files set(ament_cmake_copyright_FOUND TRUE) # the following line skips cpplint (only works in a git repo) # comment the line when this package is in a git repo and when # a copyright and license is added to all source files set(ament_cmake_cpplint_FOUND TRUE) ament_lint_auto_find_test_dependencies() endif() # 6. 生成包的环境 ament_package() 2.6.3 编译并运行C/C++自定义话题发布方功能包 编译： colcon build --packages-select cpp_idl_pub 激活环境：. install/setup.bash 运行：ros2 run cpp_idl_pub cppIdlPubNode pldz@pldz-pc:~/share/ROS2_DEMO/2_Chapter/code$ colcon build --packages-select cpp_idl_pub Starting &gt;&gt;&gt; cpp_idl_pub Finished &lt;&lt;&lt; cpp_idl_pub [10.0s] Summary: 1 package finished [10.4s] pldz@pldz-pc:~/share/ROS2_DEMO/2_Chapter/code$ . install/setup.bash pldz@pldz-pc:~/share/ROS2_DEMO/2_Chapter/code$ ros2 run cpp_idl_pub cppIdlPubNode [INFO] [1683041064.126034476] [CppIdlMsgPubNode]: Student: 'zhangsan', exam time: 0, socre is : 60.000000 [INFO] [1683041064.625514370] [CppIdlMsgPubNode]: Student: 'zhangsan', exam time: 1, socre is : 60.100000 [INFO] [1683041065.125571561] [CppIdlMsgPubNode]: Student: 'zhangsan', exam time: 2, socre is : 60.200000 ^C[INFO] [1683041082.271152379] [rclcpp]: signal_handler(signum=2) 2.6.4 创建C/C++自定义话题订阅方功能包并编辑节点文件 创建ROS2功能包，包名为cpp_idl_sub，节点名称为cppIdlSubNode，并直接指定依赖项为rclcpp和student_msg，如下所示：ros2 pkg create cpp_idl_sub --build-type ament_cmake --node-name cppIdlSubNode --dependencies rclcpp student_msg 编辑节点文件：订阅Student类型的话题，话题名为myStudent: #include \"rclcpp/rclcpp.hpp\" // 1. 添加自定义消息头文件，如果vscode出现下划线警告，则需要配置settings.json添加include路径 #include \"student_msg/msg/student.hpp\" // 占位符，结合std::bind函数的绑定使用 using std::placeholders::_1; // 2. 引入Student.msg生成的Student类 using student_msg::msg::Student; class CppIdlMsgSub: public rclcpp::Node { public: /* 3. ROS2节点的构造函数，其中包括一个node对象（初始化时候没有给出节点的名称）， * 和属性exam_（初始化为0,类型为size_t)，以及属性socre_（类型为double_t初始值为60.0） */ CppIdlMsgSub(const char* nodeName):Node(nodeName) { subscription_ = this-&gt;create_subscription&lt;Student&gt;( \"myStudent\", 10, std::bind(&amp;CppIdlMsgSub::topic_callback, this, _1)); } private: // 4. 定义订阅到消息的回调函数 void topic_callback(const Student &amp; stu) const { RCLCPP_INFO(this-&gt;get_logger(), \"I heard: %s, exam: %d, score: %f\", stu.name.c_str(),stu.exam, stu.score); } // 5. 计时器、发布者和计数器字段的声明 rclcpp::Subscription&lt;Student&gt;::SharedPtr subscription_; }; int main(int argc, char * argv[]) { rclcpp::init(argc, argv); // 创建节点，给出构造的节点名为CppIdlMsgSubNode rclcpp::spin(std::make_shared&lt;CppIdlMsgSub&gt;(\"CppIdlMsgSubNode\")); rclcpp::shutdown(); return 0; } 2.6.5 编译并运行C/C++自定义话题订阅节点 由于在创建包时候已经指定了依赖项，可以不用再进行配置packages.xml和CMakeLists.txt文件，直接编译colcon build --packages-select cpp_idl_sub 激活环境：. install/setup.bash 运行： 2.7 使用Python实现自定义话题通讯 2.7.1 创建Python自定义话题订阅方节点并编写节点内容 创建ROS2 Python发布方功能包，包名为python_idl_pub,节点名为pythonIdlPubNode：ros2 pkg create python_idl_pub --build-type ament_python --node-name pythonIdlPubNode 配置Vscode环境：在settings.json中添加Python的依赖项位置，虽然编译不影响报错，但是vscode的警告看着也不习惯： 编写订阅节点： import rclpy from rclpy.node import Node # 1. 导入包，如果vscode下划线警告，则需要配置settings.json from student_msg.msg import Student class PythonIdlPub(Node): def __init__(self, nodeName): # 1. 初始化父类构造函数，其中节点名需要创建时候指定 super().__init__(nodeName) self.exam_ = 0 self.score_ = 60.0 # 2. 声明发布者，发布消息类型为Student，话题名为myStudent,队列大小为10 self.publisher_ = self.create_publisher(Student, 'myStudent', 10) # 3. 创建定时器，其中更新频率为0.5秒，并绑定回调函数 self.timer = self.create_timer(0.5, self.timer_callback) # 4. 定义回调函数 def timer_callback(self): stu = Student() stu.name = \"zhangsan\" stu.exam = self.exam_ stu.score = self.score_ self.publisher_.publish(stu) self.get_logger().info('Publishing: name: {}, exam:{}, score:{}'.format(stu.name,stu.exam,stu.score)) self.exam_ += 1 self.score_ += 0.1 def main(args=None): rclpy.init(args=args) pythonIdlPubNode = PythonIdlPub(\"pythonIdlPubNode\") rclpy.spin(pythonIdlPubNode) # 销毁节点 pythonIdlPubNode.destroy_node() rclpy.shutdown() if __name__ == '__main__': main() 2.7.2 配置Python自定义订阅方功能包 配置packages.xml增加rclpy和student_msg两个依赖项，注意Python本身是可执行文件，因此它的为&lt;exec_depend&gt;与C/C++的&lt;depend&gt;关键字不同： &lt;?xml version=\"1.0\"?&gt; &lt;?xml-model href=\"http://download.ros.org/schema/package_format3.xsd\" schematypens=\"http://www.w3.org/2001/XMLSchema\"?&gt; &lt;package format=\"3\"&gt; &lt;name&gt;python_idl_pub&lt;/name&gt; &lt;version&gt;0.0.0&lt;/version&gt; &lt;description&gt;TODO: Package description&lt;/description&gt; &lt;maintainer email=\"pldz@R7000.com\"&gt;pldz&lt;/maintainer&gt; &lt;license&gt;TODO: License declaration&lt;/license&gt; &lt;test_depend&gt;ament_copyright&lt;/test_depend&gt; &lt;test_depend&gt;ament_flake8&lt;/test_depend&gt; &lt;test_depend&gt;ament_pep257&lt;/test_depend&gt; &lt;test_depend&gt;python3-pytest&lt;/test_depend&gt; &lt;!-- 添加依赖项 --&gt; &lt;exec_depend&gt;rclpy&lt;/exec_depend&gt; &lt;exec_depend&gt;student_msg&lt;/exec_depend&gt; &lt;export&gt; &lt;build_type&gt;ament_python&lt;/build_type&gt; &lt;/export&gt; &lt;/package&gt; 配置setup.py文件，事实上，我们已经创建包的时候已经指定了节点名，其实应该是不用配置生成节点的main入口的： from setuptools import setup package_name = 'python_idl_pub' setup( name=package_name, version='0.0.0', packages=[package_name], data_files=[ ('share/ament_index/resource_index/packages', ['resource/' + package_name]), ('share/' + package_name, ['package.xml']), ], install_requires=['setuptools'], zip_safe=True, maintainer='pldz', maintainer_email='pldz@R7000.com', description='TODO: Package description', license='TODO: License declaration', tests_require=['pytest'], # 配置节点的main函数入口 entry_points={ 'console_scripts': [ 'pythonIdlPubNode = python_idl_pub.pythonIdlPubNode:main' ], }, ) 2.7.3 编译并运行Python自定义话题发布方 编译：colcon build --packages-select python_idl_pub 激活环境：. install/setup.bash 运行节点：ros2 run python_idl_pub pythonIdlPubNode pldz@pldz-pc:~/share/ROS2_DEMO/2_Chapter/code$ ros2 run python_idl_pub pythonIdlPubNode [INFO] [1683044269.902750751] [pythonIdlPubNode]: Publishing: name: zhangsan, exam:0, score:60.0 [INFO] [1683044270.393748471] [pythonIdlPubNode]: Publishing: name: zhangsan, exam:1, score:60.1 [INFO] [1683044270.891683074] [pythonIdlPubNode]: Publishing: name: zhangsan, exam:2, score:60.2 2.7.4 创建Python自定义话题订阅方 创建Python功能包时，包名为python_idl_sub，节点名为pythonIdlSubNode，直接指定依赖项rclpy和student_msg：ros2 pkg create python_idl_sub --build-type ament_python --node-name pythonIdlSubNode --dependencies rclpy student_msg 编写节点： import rclpy from rclpy.node import Node # 1. 导入包，如果vscode下划线警告，则需要配置settings.json from student_msg.msg import Student class PythonIdlSub(Node): def __init__(self, nodeName): # 1. 构造函数，初始化node节点 super().__init__(nodeName) # 2. 声明订阅者，订阅话题`myTopicNmae`,并绑定回调函数 self.subscription = self.create_subscription(Student,'myStudent',self.listener_callback,10) # 3. 定义回调函数 def listener_callback(self, stu:Student): self.get_logger().info('I heard: name:{}, exam:{}, score{}'.format(stu.name, stu.exam, stu.score)) def main(args=None): rclpy.init(args=args) pythonIdlSubNode = PythonIdlSub(\"pythonIdlSubNode\") rclpy.spin(pythonIdlSubNode) pythonIdlSubNode.destroy_node() rclpy.shutdown() if __name__ == '__main__': main() 2.7.5 编译运行Python发布方节点 由于指定了依赖项，直接编译即可: colcon build --packages-select python_idl_sub 激活环境: . install/setup.bash 运行所有节点： 2.8 话题通讯小结 创建功能包时，如果能够直接指定节点名和依赖项，可以省去很大部分的配置工作 C/C++手动配置功能包时，packages.xml配置依赖项，CMakeLists.txt配置编译的内容，包括find_package；add_executable；target_include_directories；ament_target_dependencies；install；ament_package这六个部分 Python手动配置功能包时，packages.xml配置可执行的依赖项exec_depend而不是depend,并且在setup.py中主要配置节点的main函数入口 自定义话题通讯，本质是创建一个C/C++的功能包，将里面的自定义消息编译成可以使用的.c和.py文件，值得注意的是，生成好的中间文件是存放在 工作空间的install文件夹下，如果这个这个工作空间的install找不到或者不是一个，那是需要再进一步的手动配置的"
  },"/ros2_basic/2023-02-02-2_1_ROS2%E8%AF%9D%E9%A2%98%E9%80%9A%E8%AE%AF%E5%9F%BA%E7%A1%80.html": {
    "title": "2 ROS2话题通讯 - 话题通讯基础",
    "keywords": "ROS2_BASIC",
    "url": "/ros2_basic/2023-02-02-2_1_ROS2%E8%AF%9D%E9%A2%98%E9%80%9A%E8%AE%AF%E5%9F%BA%E7%A1%80.html",
    "body": "2.1 ROS2话题通讯介绍 话题通信是一种单向通信模型，一方发布数据，一方订阅数据，适用于连续不间断的通讯场景，如小车SLAM导航过程中的位姿信息等等。话题是一个通讯的管道，ROS2的话题发布方和接收方无论是C/C++还是Python都可以发布/订阅相同的话题实现通讯，一个话题的发布方，可以有多个订阅方，如下图所示： Tips：节点（Node）的概念 ROS的通信对象的构建都依赖于节点（回想之前快速体验的 rclcpp::Node 或者是 from rclpy.node import Node 都是为了创建一个节点所导入的父类），一般情况下一个节点都对应某一个功能模块（例如一个节点负责持续发布SLAM位姿数据等），一个C/C++ 或者Python的文件代码，可以包括多个节点。 2.2 ROS2常用的消息类型介绍 2.2.1 std_msgs消息类型 参考内容 官方文档 std_msgs Msg/Srv Documentation 详解常用的ROS内置消息类型 ROS中geometry_msgs消息类型、nav_msg消息 std_msgs 属于ROS的标准数据类型库，主要包括的消息类型有： ROS type C++ type bool bool byte uint8_t char char float32 float float64 double int8 int8_t uint8 uint8_t int16 int16 uint16 uint16 int32 int32 uint32 uint32 int64 int64 uint64 uint64_t string std::string static array std::array&lt;T, N&gt; 数组和有条件的字符串的映射 ROS type C++ type unbounded dynamic array std::vector bounded dynamic array custom_class&lt;T, N&gt; bounded string std::string 2.2.2 geometry_msgs消息类型 参考内容 官方文档 geometry_msgs Msg/Srv Documentation ROS中geometry_msgs常用消息类型 ROS2 humble的接口官方API geometry_msgs：常见的几何信息（如点、向量和姿势）提供ROS消息，其中包括的内容有，具体的话题参数，例如在使用乌龟节点控制乌龟运动的cmd_vel话题就是采用geometry_msgs/Twist编写的，具体的用法，可以去查阅官网。 Accel AccelStamped AccelWithCovariance AccelWithCovarianceStamped Inertia InertiaStamped Point Point32 PointStamped Polygon PolygonStamped Pose Pose2D PoseArray PoseStamped PoseWithCovariance PoseWithCovarianceStamped Quaternion QuaternionStamped Transform TransformStamped Twist TwistStamped TwistWithCovariance TwistWithCovarianceStamped Vector3 Vector3Stamped Wrench WrenchStamped 2.3 使用C/C++创建基础消息类型的话题通讯 参考内容： Writing a simple publisher and subscriber (C++) 2.2.2_话题通信_原生消息(C++)_01发布方01源码分析 2.3.1 创建C/C++发布话题信息的功能包并配置VSCode环境 创建发布者功能包时，不添加任何依赖项，回顾之前的项目配置 创建ROS2 C/C++功能包，其中包名为 cppBaseMsgPub :ros2 pkg create cppBaseMsgPub --build-type ament_cmake Tips：这里补充还是推荐才有下划线割开的功能包命名方法而不是大小写混合，否则会出错 如果尝试命名节点和依赖项，可以直接采用这种方式，节点名为 cppBaseMsgPubNode ，依赖 rclcpp 和 std_msgs：ros2 pkg create cppBaseMsgPub --build-type ament_cmake --node-name cppBaseMsgPubNode --dependencies rclcpp std_msgs pldz@pldz-pc:~/share/ROS2_DEMO/2_Chapter/code$ ros2 pkg create cppBaseMsgPub --build-type ament_cmake going to create a new package ... 手动省略 creating ./cppBaseMsgPub/CMakeLists.txt [WARNING]: Unknown license 'TODO: License declaration'. This has been set in the package.xml, but no LICENSE file has been created. It is recommended to use one of the ament license identitifers: ... 手动省略 MIT-0 在工作空间（这个是vscode的概念）下创建.vsocde文件夹和settings.json文件，配置VSCode的settings.json文件，添加路径 { \"C_Cpp.default.includePath\": [\"/opt/ros/humble/include/**\"], \"python.analysis.extraPaths\": [\"/opt/ros/humble/local/lib/python3.10/dist-packages/\"], } 此时的文件结构如下：可以看到，如果单纯的指定了包名但是没有指定节点名，不会在src目录下创建.cpp文件 pldz@pldz-pc:~/share/ROS2_DEMO/2_Chapter/code$ tree -a .(注释：这个就是工作空间) ├── cppBaseMsgPub │ ├── CMakeLists.txt │ ├── include │ │ └── cppBaseMsgPub │ ├── package.xml │ └── src └── .vscode └── settings.json 5 directories, 3 files 完成之后配置VSCode环境 2.3.2 编写ROS2发布话题节点CPP文件 编写发布者代码：根据官网提供的案例，在包的src目录下，创建cppBaseMsgPubNode.cpp文件，对cppBaseMsgPubNode.cpp进行发布者内容编写：总的来说，主要包括创建构造发布节点，计数属性，然后绑定发布函数到定时器上 #include \"rclcpp/rclcpp.hpp\" #include \"std_msgs/msg/string.hpp\" // C++14中的时间库 using namespace std::chrono_literals; class CppBaseMsgPub: public rclcpp::Node { public: /* 1. ROS2节点的构造函数，其中包括一个node对象（初始化时候没有给出节点的名称）， * 和属性count_(默认初始化为0) */ CppBaseMsgPub(const char* nodeName):Node(nodeName), count_(0) { // 2. 创建发布者,参数分别为话题名称myTopicName，和发布队列的长队为10 publisher_ = this-&gt;create_publisher&lt;std_msgs::msg::String&gt;(\"myTopicName\", 10); // 3. 创建定时器，设置发布的频率，并绑定定时执行的事件，这里给到的是CppBaseMsgPub类的函数 timer_ = this-&gt;create_wall_timer(500ms, std::bind(&amp;CppBaseMsgPub::timer_callback, this)); } private: // 4. 定义回调函数 void timer_callback() { auto message = std_msgs::msg::String(); message.data = \"Hello, world! \" + std::to_string(count_++); RCLCPP_INFO(this-&gt;get_logger(), \"Cpp Publish: '%s'\", message.data.c_str()); publisher_-&gt;publish(message); } // 5. 计时器、发布者和计数器字段的声明 rclcpp::TimerBase::SharedPtr timer_; rclcpp::Publisher&lt;std_msgs::msg::String&gt;::SharedPtr publisher_; size_t count_; }; int main(int argc, char * argv[]) { rclcpp::init(argc, argv); // 创建节点，给出构造的节点名为cppBaseMsgPubNode rclcpp::spin(std::make_shared&lt;CppBaseMsgPub&gt;(\"cppBaseMsgPubNode\")); rclcpp::shutdown(); return 0; } 2.3.3 配置C/C++发布话题功能包并编译 配置package.xml：package.xml主要对C/C++的功能包依赖项和发布信息进行配置，由于在节点cppBaseMsgPubNode.cpp中主要用到了rclcpp和std_msgs两个依赖，因此package.xml的配置主要如下： &lt;?xml version=\"1.0\"?&gt; &lt;?xml-model href=\"http://download.ros.org/schema/package_format3.xsd\" schematypens=\"http://www.w3.org/2001/XMLSchema\"?&gt; &lt;package format=\"3\"&gt; &lt;name&gt;cppBaseMsgPub&lt;/name&gt; &lt;version&gt;0.0.0&lt;/version&gt; &lt;description&gt;TODO: Package description&lt;/description&gt; &lt;maintainer email=\"pldz@R7000.com\"&gt;pldz&lt;/maintainer&gt; &lt;license&gt;TODO: License declaration&lt;/license&gt; &lt;buildtool_depend&gt;ament_cmake&lt;/buildtool_depend&gt; &lt;test_depend&gt;ament_lint_auto&lt;/test_depend&gt; &lt;test_depend&gt;ament_lint_common&lt;/test_depend&gt; &lt;!-- 添加依赖项 --&gt; &lt;depend&gt;rclcpp&lt;/depend&gt; &lt;depend&gt;std_msgs&lt;/depend&gt; &lt;export&gt; &lt;build_type&gt;ament_cmake&lt;/build_type&gt; &lt;/export&gt; &lt;/package&gt; 配置CmakeLists.txt：主要包括的内容有五部分，并且需要按照顺序进行配置好 find_package() // 1. 列出依赖项，通俗的说是项目编译所需要的全部依赖项名称，节点和项目是两个概念，一个项目可以有多个节点 add_executable() // 2. 可执行文件的路径，通俗来说是编译节点的main函数入口 target_include_directories() // 3. 编译节点所需要的include的位置 ament_target_dependencies() // 4. 编译节点所需要的依赖项，这一步的目的是连接编译该节点所需要的依赖项 install() // 5. 通俗来说，是将编译好的节点给拷贝到ROS功能包的目录，使得能够通过指令ros2 run &lt;包名&gt; &lt;节点名&gt;的配置，默认这一步的目的就是将build文件夹的内容拷贝到install的lib文件夹下 ament_package() // 6. 生成ament工具的环境，缺少这一步，无法在install文件夹下生成setup.bash文件等等 因此该项目的CmakeLists.txt如下所示： cmake_minimum_required(VERSION 3.8) project(cppBaseMsgPub) if(CMAKE_COMPILER_IS_GNUCXX OR CMAKE_CXX_COMPILER_ID MATCHES \"Clang\") add_compile_options(-Wall -Wextra -Wpedantic) endif() # find dependencies find_package(ament_cmake REQUIRED) # uncomment the following section in order to fill in # further dependencies manually. # find_package(&lt;dependency&gt; REQUIRED) # 1. 添加依赖项列表 find_package(rclcpp REQUIRED) find_package(std_msgs REQUIRED) # 2. 生成节点的主函数入口和节点名称 add_executable(cppBaseMsgPubNode src/cppBaseMsgPubNode.cpp) # 3. Include路径配置，这里其实没有用上，可以不用配置 target_include_directories(cppBaseMsgPubNode PUBLIC $&lt;BUILD_INTERFACE:${CMAKE_CURRENT_SOURCE_DIR}/include&gt; $&lt;INSTALL_INTERFACE:include&gt;) # 4. ament工具的编译所需要的依赖 ament_target_dependencies( cppBaseMsgPubNode \"rclcpp\" \"std_msgs\" ) # 5. 安装规则 install(TARGETS cppBaseMsgPubNode DESTINATION lib/${PROJECT_NAME}) if(BUILD_TESTING) find_package(ament_lint_auto REQUIRED) # the following line skips the linter which checks for copyrights # comment the line when a copyright and license is added to all source files set(ament_cmake_copyright_FOUND TRUE) # the following line skips cpplint (only works in a git repo) # comment the line when this package is in a git repo and when # a copyright and license is added to all source files set(ament_cmake_cpplint_FOUND TRUE) ament_lint_auto_find_test_dependencies() endif() # 6. 配置ament环境，生成功能包 ament_package() 编译功能包：colcon build： pldz@pldz-pc:~/share/ROS2_DEMO/2_Chapter/code$ colcon build WARNING: Package name \"cppBaseMsgPub\" does not follow the naming conventions. It should start with a lower case letter and only contain lower case letters, digits, underscores, and dashes. Starting &gt;&gt;&gt; cppBaseMsgPub ... 手动省略 Summary: 1 package finished [4.44s] 1 package had stderr output: cppBaseMsgPub 运行节点：激活功能包环境source ./install/setup.bash，然后运行ros2 run cppBaseMsgPub cppBaseMsgPubNode pldz@pldz-pc:~/share/ROS2_DEMO/2_Chapter/code$ source ./install/setup.bash pldz@pldz-pc:~/share/ROS2_DEMO/2_Chapter/code$ ros2 run cppBaseMsgPub cppBaseMsgPubNode [INFO] [1683015931.213646661] [cppBaseMsgPubNode]: Cpp Publish: 'Hello, world! 0' [INFO] [1683015931.713349843] [cppBaseMsgPubNode]: Cpp Publish: 'Hello, world! 1' [INFO] [1683015932.213429705] [cppBaseMsgPubNode]: Cpp Publish: 'Hello, world! 2' ^C[INFO] [1683015932.588202160] [rclcpp]: signal_handler(signum=2) pldz@pldz-pc:~/share/ROS2_DEMO/2_Chapter/code$ 2.3.4 创建C/C++订阅话题的功能包 由于上面操作过一遍从功能包开始的配置节点依赖项，这里直接提前在创建功能包的时候直接指定依赖项，省去后续的配置，取名订阅话题的功能包为cppBaseMsgSub，节点名称为cppBaseMsgSubNode，如ros2 pkg create cppBaseMsgSub --build-type ament_cmake --node-name cppBaseMsgSubNode --dependencies rclcpp std_msgs Tips：这里补充还是推荐才有下划线割开的功能包命名方法而不是大小写混合，否则会出错 pldz@pldz-pc:~/share/ROS2_DEMO/2_Chapter/code$ ros2 pkg create cppBaseMsgSub --build-type ament_cmake --node-name cppBaseMsgSubNode --dependencies rclcpp std_msgs going to create a new package package name: cppBaseMsgSub ... 手动省略 MIT MIT-0 2.3.1节在工作空间下配置过vscode的settings.json这里就不再配置vscode了 2.3.5 编写ROS2订阅话题节点CPP文件 直接在cppBaseMsgSubNode.cpp文件进行编辑，创建订阅节点，订阅话题myTopicName与之前的发布话题类型和名称一致即可： #include \"rclcpp/rclcpp.hpp\" #include \"std_msgs/msg/string.hpp\" // 占位符，结合std::bind函数的绑定使用 using std::placeholders::_1; class CppBaseMsgSub: public rclcpp::Node { public: /* 1. ROS2节点的构造函数 */ CppBaseMsgSub(const char* nodeName):Node(nodeName) { // 2.声明订阅话题类型，并绑定回调函数 subscription_ = this-&gt;create_subscription&lt;std_msgs::msg::String&gt;( \"myTopicName\", 10, std::bind(&amp;CppBaseMsgSub::topic_callback, this, _1)); } private: // 3. 定义订阅到消息的回调函数 void topic_callback(const std_msgs::msg::String &amp; msg) const { RCLCPP_INFO(this-&gt;get_logger(), \"I heard: '%s'\", msg.data.c_str()); } // 4. 计时器、发布者和计数器字段的声明 rclcpp::Subscription&lt;std_msgs::msg::String&gt;::SharedPtr subscription_; }; int main(int argc, char * argv[]) { rclcpp::init(argc, argv); // 初始化订阅节点 rclcpp::spin(std::make_shared&lt;CppBaseMsgSub&gt;(\"cppBaseMsgSubNode\")); rclcpp::shutdown(); return 0; } 2.3.6 配置C/C++订阅话题功能包并编译 由于是直接在创建包的时候指定了依赖项，可以直接编译colcon build，运行查看效果： 2.4 使用Python创建基础消息类型的话题通讯 2.4.1 创建Python发布话题功能包并编写节点文件 创建Python发布者功能包，其中功能包名称为pythonBaseMsgPub，不指定节点名和依赖项，后续手动配置packages.xml和setup.py：ros2 pkg create pythonBaseMsgPub --build-type ament_python，目前文件结构如下所示： Tips：这里补充还是推荐才有下划线割开的功能包命名方法而不是大小写混合，否则会出错 在pythonBaseMsgPub/pythonBaseMsgPub文件夹下创建pythonBaseMsgPubNode.py文件，内容如下所示 import rclpy from rclpy.node import Node from std_msgs.msg import String class PythonBaseMsgPub(Node): def __init__(self, nodeName): # 1. 初始化父类构造函数，其中节点名需要创建时候指定,计数属性count_从0开始 super().__init__(nodeName) self.count_ = 0 # 2. 声明发布者，发布消息类型为String，话题名为myTopicName,队列大小为10 self.publisher_ = self.create_publisher(String, 'myTopicName', 10) # 3. 创建定时器，其中更新频率为0.5秒，并绑定回调函数 self.timer = self.create_timer(0.5, self.timer_callback) # 4. 定义回调函数 def timer_callback(self): msg = String() msg.data = 'Hello World: %d' % self.count_ self.publisher_.publish(msg) self.get_logger().info('Publishing: \"%s\"' % msg.data) self.count_ += 1 def main(args=None): rclpy.init(args=args) pythonBaseMsgPubNode = PythonBaseMsgPub(\"pythonBaseMsgPubNode\") rclpy.spin(pythonBaseMsgPubNode) # 销毁节点 pythonBaseMsgPubNode.destroy_node() rclpy.shutdown() if __name__ == '__main__': main() 2.4.2 配置Python项目并运行 配置Python项目的packages.xml：主要是添加可执行的依赖项rclpy和std_msgs &lt;?xml version=\"1.0\"?&gt; &lt;?xml-model href=\"http://download.ros.org/schema/package_format3.xsd\" schematypens=\"http://www.w3.org/2001/XMLSchema\"?&gt; &lt;package format=\"3\"&gt; &lt;name&gt;pythonBaseMsgPub&lt;/name&gt; &lt;version&gt;0.0.0&lt;/version&gt; &lt;description&gt;TODO: Package description&lt;/description&gt; &lt;maintainer email=\"pldz@R7000.com\"&gt;pldz&lt;/maintainer&gt; &lt;license&gt;TODO: License declaration&lt;/license&gt; &lt;!-- 与C/C++不同的是,Python文件是一个可执行的脚本,因此依赖项的关键字为exec_depend --&gt; &lt;exec_depend&gt;rclpy&lt;/exec_depend&gt; &lt;exec_depend&gt;std_msgs&lt;/exec_depend&gt; &lt;test_depend&gt;ament_copyright&lt;/test_depend&gt; &lt;test_depend&gt;ament_flake8&lt;/test_depend&gt; &lt;test_depend&gt;ament_pep257&lt;/test_depend&gt; &lt;test_depend&gt;python3-pytest&lt;/test_depend&gt; &lt;export&gt; &lt;build_type&gt;ament_python&lt;/build_type&gt; &lt;/export&gt; &lt;/package&gt; 配置setup.py文件指定节点的main函数入口： from setuptools import setup package_name = 'pythonBaseMsgPub' setup( name=package_name, version='0.0.0', packages=[package_name], data_files=[ ('share/ament_index/resource_index/packages', ['resource/' + package_name]), ('share/' + package_name, ['package.xml']), ], install_requires=['setuptools'], zip_safe=True, maintainer='pldz', maintainer_email='pldz@R7000.com', description='TODO: Package description', license='TODO: License declaration', tests_require=['pytest'], # 指定编译节点的main函数入口 entry_points={ 'console_scripts': [ 'pythonBaseMsgPubNode = pythonBaseMsgPub.pythonBaseMsgPubNode:main', ], }, ) 编译：colcon build 2.4.3 创建Python订阅话题功能包并编写节点 创建功能包pythonBaseMsgSub，并直接给出节点名pythonBaseMsgSubNode和依赖项rclpy和std_msgs，如下所示：ros2 pkg create pythonBaseMsgSub --build-type ament_python --node-name pythonBaseMsgSubNode --dependencies rclpy std_msgs Tips：这里补充还是推荐才有下划线割开的功能包命名方法而不是大小写混合，否则会出错 编写订阅者节点： import rclpy from rclpy.node import Node from std_msgs.msg import String class PythonBaseMsgSub(Node): def __init__(self, nodeName): # 1. 构造函数，初始化node节点 super().__init__(nodeName) # 2. 声明订阅者，订阅话题`myTopicNmae`,并绑定回调函数 self.subscription = self.create_subscription(String,'myTopicName',self.listener_callback,10) # 3. 定义回调函数 def listener_callback(self, msg): self.get_logger().info('I heard: \"%s\"' % msg.data) def main(args=None): rclpy.init(args=args) pythonBaseMsgSubNode = PythonBaseMsgSub(\"pythonBaseMsgSubNode\") rclpy.spin(pythonBaseMsgSubNode) pythonBaseMsgSubNode.destroy_node() rclpy.shutdown() if __name__ == '__main__': main() 2.4.4 编译运行节点 由于指定了依赖项和节点名，不需要多余的进行packages.xml和setup.py的配置 编译colcon build，联合C/C++的一起运行，可以看到话题通讯是多对多的"
  },"/ros2_basic/2023-02-01-1_1_Ubuntu%E9%85%8D%E7%BD%AE%E4%B8%8EROS2%E5%BF%AB%E9%80%9F%E4%BD%93%E9%AA%8C.html": {
    "title": "1 Ubuntu配置与ROS2快速体验",
    "keywords": "ROS2_BASIC",
    "url": "/ros2_basic/2023-02-01-1_1_Ubuntu%E9%85%8D%E7%BD%AE%E4%B8%8EROS2%E5%BF%AB%E9%80%9F%E4%BD%93%E9%AA%8C.html",
    "body": "1.1 Ubuntu配置与ROS2安装 1.1.1 Ubuntu22.04安装 下载Ubuntu22.04：本文选择 中科大镜像网 ，选择Ubuntu22.04镜像下载，后续放入VMware进行 断网安装 VMware15链接： 链接：https://pan.baidu.com/s/1BbaGtDhjVXCWeS2vuk3bRw 提取码：7lzk 复制这段内容后打开百度网盘手机App，操作更方便哦 Ubuntu22.04 换源：将桌面版本的Ubuntu的软件更新设置来源为国内的镜像，或者直接输入命令sudo gedit /etc/apt/sources.list将内容改为如下所示： deb https://mirrors.ustc.edu.cn/ubuntu/ jammy main restricted universe multiverse deb-src https://mirrors.ustc.edu.cn/ubuntu/ jammy main restricted universe multiverse deb https://mirrors.ustc.edu.cn/ubuntu/ jammy-updates main restricted universe multiverse deb-src https://mirrors.ustc.edu.cn/ubuntu/ jammy-updates main restricted universe multiverse deb https://mirrors.ustc.edu.cn/ubuntu/ jammy-backports main restricted universe multiverse deb-src https://mirrors.ustc.edu.cn/ubuntu/ jammy-backports main restricted universe multiverse deb https://mirrors.ustc.edu.cn/ubuntu/ jammy-security main restricted universe multiverse deb-src https://mirrors.ustc.edu.cn/ubuntu/ jammy-security main restricted universe multiverse deb https://mirrors.ustc.edu.cn/ubuntu/ jammy-proposed main restricted universe multiverse deb-src https://mirrors.ustc.edu.cn/ubuntu/ jammy-proposed main restricted universe multiverse 1.1.2 下载安装ROS2 输入命令sudo apt-get update -y对软件源进行更新，输入sudo apt-get upgrade -y对软件进行更新： sudo apt-get update -y &amp;&amp; sudo apt-get upgrade -y 获取ROS2的秘钥，并ROS2的存储库添加到源列表： sudo apt install curl gnupg lsb-release &amp;&amp; sudo curl -sSL https://raw.githubusercontent.com/ros/rosdistro/master/ros.key -o /usr/share/keyrings/ros-archive-keyring.gpg echo \"deb [arch=$(dpkg --print-architecture) signed-by=/usr/share/keyrings/ros-archive-keyring.gpg] http://packages.ros.org/ros2/ubuntu $(source /etc/os-release &amp;&amp; echo $UBUNTU_CODENAME) main\" | sudo tee /etc/apt/sources.list.d/ros2.list &gt; /dev/null 如果出现关于 raw.githubusercontent.com 连接失败的处理 访问 https://tool.lu/ip/ 并输入域名 raw.githubusercontent.com，查询 ip 地址，这里查询到的是 185.199.108.133 修改 sudo gedit /etc/hosts文件,并手动添加DNS解析： 下载ROS2-humble：更新软件到最新版本，然后下载ROS2-humble： sudo apt-get update -y &amp;&amp; sudo apt-get upgrade -y sudo apt install ros-humble-desktop 安装colcon构建工具： 不同于之前ROS1的catkin工具，ROS2用colcon进行包的构建：sudo apt install python3-colcon-common-extensions 1.1.3 配置ROS2环境并测试 配置ROS2环境： 默认ROS2-humble安装在/opt/ros/humble/下，将ROS2的环境添加到用户环境文件~/.bashrc中，输入echo \"source /opt/ros/humble/setup.bash\" &gt;&gt; ~/.bashrc 测试ROS2：ros2 run turtlesim turtlesim_node和ros2 run turtlesim turtle_teleop_key运行小乌龟 1.2 使用VSCode搭建ROS2开发环境 1.2.1 安装并配置VSCode 安装VSCode: VSCode下载地址，持续下一步即可安装完成。 下载完成后安装VSCode插件：插件主要包括 C/C++ 和 Python 以及 CMake 的插件，如下图所示： 1.2.2 创建ROS2工程的方法 ROS2 create命令：通过 ros2 pkg create --help 熟悉创建ROS2项目的方法 pldz@pldz-pc:~/share/ROS2_DEMO/1_Chapter$ ros2 pkg create --help usage: ros2 pkg create [-h] [--package-format {2,3}] [--description DESCRIPTION] [--license LICENSE] [--destination-directory DESTINATION_DIRECTORY] [--build-type {cmake,ament_cmake,ament_python}] [--dependencies DEPENDENCIES [DEPENDENCIES ...]] [--maintainer-email MAINTAINER_EMAIL] [--maintainer-name MAINTAINER_NAME] [--node-name NODE_NAME] [--library-name LIBRARY_NAME] package_name Create a new ROS 2 package positional arguments: package_name The package name options: -h, --help show this help message and exit --package-format {2,3}, --package_format {2,3} The package.xml format. --description DESCRIPTION The description given in the package.xml --license LICENSE The license attached to this package; this can be an arbitrary string, but a LICENSE file will only be generated if it is one of the supported licenses (pass '?' to get a list) --destination-directory DESTINATION_DIRECTORY Directory where to create the package directory --build-type {cmake,ament_cmake,ament_python} The build type to process the package with --dependencies DEPENDENCIES [DEPENDENCIES ...] list of dependencies --maintainer-email MAINTAINER_EMAIL email address of the maintainer of this package --maintainer-name MAINTAINER_NAME name of the maintainer of this package --node-name NODE_NAME name of the empty executable --library-name LIBRARY_NAME name of the empty library 下面对上诉的命令进行简单的介绍： 提示当中的[]的内容表示命令关键字，{}的内容表示可以携带的参数示例，例如创建 --build-type 后面就可以接着 ament_cmake 参数 [--destination-directory DESTINATION_DIRECTORY] ：ROS2的项目的位置，即在哪里创建你的ROS2项目 [--build-type {cmake,ament_cmake,ament_python}] ：ROS2编译项目的方式，有cmake ament_camke和ament_python三种可选，ament_cmake是基于cmake的一个cmake升级工具， 了解更多的ROS2 ament工具：(https://blog.csdn.net/gongdiwudu/article/details/126192244) [--dependencies] ：ROS2项目的依赖项，这部分内容后面可以手动增加，其中常见的rclpy 是 python的节点依赖项，rclcpp是C/C++节点的依赖项，（rcl表示ros2 client） [--node-name] ：预先设置的ROS2节点名字 因此可以使用命令：ros2 pkg create &lt;你的项目名字&gt; --build-type &lt;选择cmake/ament_camke/ament_python三者之一作为项目的编译工具&gt; --node-name &lt;节点名称，这一项可以不写，后续手动配置&gt; --dependencies &lt;依赖项名字，例如在ROS1中常用的rclpy rclcpp std_msgs sensor_msgs等&gt;，如： Tips：这里补充还是推荐才有下划线割开的功能包命名方法而不是大小写混合，否则会出错 ros2 pkg create demo --build-type ament_cmake --node-name demo_node --dependencies rclcpp 1.2.3 使用VSCode创建ROS2的C/C++项目 创建ROS2 C++工程：ros2 pkg create vscodeCppDemo --build-type ament_cmake --node-name vscodeCppDemoNode --dependencies rclcpp std_msgs Tips：这里补充还是推荐才有下划线割开的功能包命名方法而不是大小写混合，否则会出错 查看工程目录结构：tree . ，可以发现在src目录下 存在了节点名称的cpp文件 ，即ROS2项目已经构建了配置好节点内容的工程 pldz@pldz-pc:~/share/ROS2_DEMO/1_Chapter/code$ ros2 pkg create vscodeCppDemo --build-type ament_cmake --node-name vscodeCppDemoNode --dependencies rclcpp std_msgs going to create a new package package name: vscodeCppDemo destination directory: /mnt/hgfs/VMware/ROS2_DEMO/1_Chapter/code package format: 3 version: 0.0.0 description: TODO: Package description maintainer: ['pldz &lt;pldz@R7000.com&gt;'] licenses: ['TODO: License declaration'] build type: ament_cmake dependencies: ['rclcpp', 'std_msgs'] node_name: vscodeCppDemoNode creating folder ./vscodeCppDemo creating ./vscodeCppDemo/package.xml creating source and include folder creating folder ./vscodeCppDemo/src creating folder ./vscodeCppDemo/include/vscodeCppDemo creating ./vscodeCppDemo/CMakeLists.txt creating ./vscodeCppDemo/src/vscodeCppDemoNode.cpp [WARNING]: Unknown license 'TODO: License declaration'. This has been set in the package.xml, but no LICENSE file has been created. It is recommended to use one of the ament license identitifers: Apache-2.0 BSL-1.0 BSD-2.0 BSD-2-Clause BSD-3-Clause GPL-3.0-only LGPL-3.0-only MIT MIT-0 pldz@pldz-pc:~/share/ROS2_DEMO/1_Chapter/code$ tree . . └── vscodeCppDemo ├── CMakeLists.txt ├── include │ └── vscodeCppDemo ├── package.xml └── src └── vscodeCppDemoNode.cpp 4 directories, 3 files 在&lt;ROS2工程目录下&gt;/src/&lt;节点cpp&gt;.cpp进行节点编程，ROS2是C++14的编程风格： #include \"rclcpp/rclcpp.hpp\" // 继承ROS2的客户端节点 class VSCodeCppDemo: public rclcpp::Node{ public: // ROS2节点的构造函数 VSCodeCppDemo(const char* nodeName):Node(nodeName){ RCLCPP_INFO(this-&gt;get_logger(),\"hello world!\"); } }; int main(int argc, char *argv[]) { rclcpp::init(argc,argv); // 生成自定义的ROS2客户端对象, node是一个对象指针 auto node = std::make_shared&lt;VSCodeCppDemo&gt;(\"vscodeCppDemoNode\"); rclcpp::shutdown(); return 0; } 针对VSCode的settings.json进行配置：在项目下面新建 .vscode 文件夹，然后在在该文件夹下新建 settings.json , 添加下列内容： { // Settings.json的配置，主要在于添加/opt/ros/humble文件夹下的ros2的include路径 // pldz@pldz-pc:~/share/ROS2_DEMO/1_Chapter/code/.vscode$ tree . // . // └── settings.json // 0 directories, 1 file \"files.associations\": { \"cstdio\": \"cpp\" }, \"C_Cpp.default.includePath\": [\"/opt/ros/humble/include/**\"] } 配置ROS2项目的 package.xml 文件：package.xml 文件是ROS2项目的功能包管理文件，下面添加了一点注释： &lt;?xml version=\"1.0\"?&gt; &lt;?xml-model href=\"http://download.ros.org/schema/package_format3.xsd\" schematypens=\"http://www.w3.org/2001/XMLSchema\"?&gt; &lt;package format=\"3\"&gt; &lt;name&gt;vscodeCppDemo&lt;/name&gt; &lt;version&gt;0.0.0&lt;/version&gt; &lt;description&gt;TODO: Package description&lt;/description&gt; &lt;!-- 包的作者信息,主要来自Git的配置 --&gt; &lt;maintainer email=\"pldz@R7000.com\"&gt;pldz&lt;/maintainer&gt; &lt;license&gt;TODO: License declaration&lt;/license&gt; &lt;!-- 编译工程的工具 --&gt; &lt;buildtool_depend&gt;ament_cmake&lt;/buildtool_depend&gt; &lt;!-- 编译需要的依赖项,可以手动添加 --&gt; &lt;depend&gt;rclcpp&lt;/depend&gt; &lt;depend&gt;std_msgs&lt;/depend&gt; &lt;test_depend&gt;ament_lint_auto&lt;/test_depend&gt; &lt;test_depend&gt;ament_lint_common&lt;/test_depend&gt; &lt;export&gt; &lt;build_type&gt;ament_cmake&lt;/build_type&gt; &lt;/export&gt; &lt;/package&gt; 配置 CMakeLists.txt 文件：CMakeLists.txt 是ROS2项目的编译配置文件，ROS2项目采用ament_cmake工具，需要配置的包括以下6部分内容： find_package() // 1. 列出依赖项，通俗的说是项目编译所需要的全部依赖项名称，节点和项目是两个概念，一个项目可以有多个节点 add_executable() // 2. 可执行文件的路径，通俗来说是编译节点的main函数入口 target_include_directories() // 3. 编译节点所需要的include的位置 ament_target_dependencies() // 4. 编译节点所需要的依赖项，这一步的目的是连接编译该节点所需要的依赖项 install() // 5. 通俗来说，是将编译好的节点给拷贝到ROS功能包的目录，使得能够通过指令ros2 run &lt;包名&gt; &lt;节点名&gt;的配置，默认这一步的目的就是将build文件夹的内容拷贝到install的lib文件夹下 ament_package() // 6. 生成ament工具的环境，缺少这一步，无法在install文件夹下生成setup.bash文件等等 下面添加了一点注释： cmake_minimum_required(VERSION 3.8) project(vscodeCppDemo) if(CMAKE_COMPILER_IS_GNUCXX OR CMAKE_CXX_COMPILER_ID MATCHES \"Clang\") add_compile_options(-Wall -Wextra -Wpedantic) endif() # 1. find dependencies, 这里可以引入外部依赖包 find_package(ament_cmake REQUIRED) find_package(rclcpp REQUIRED) find_package(std_msgs REQUIRED) # 2. 节点(也叫可执行文件)的映射 add_executable(vscodeCppDemoNode src/vscodeCppDemoNode.cpp) # 3. Include文件的位置 target_include_directories(vscodeCppDemoNode PUBLIC $&lt;BUILD_INTERFACE:${CMAKE_CURRENT_SOURCE_DIR}/include&gt; $&lt;INSTALL_INTERFACE:include&gt;) # 4. 目标依赖库 target_compile_features(vscodeCppDemoNode PUBLIC c_std_99 cxx_std_17) # Require C99 and C++17 ament_target_dependencies( vscodeCppDemoNode \"rclcpp\" \"std_msgs\" ) # 5. 安装规则 install(TARGETS vscodeCppDemoNode DESTINATION lib/${PROJECT_NAME}) if(BUILD_TESTING) find_package(ament_lint_auto REQUIRED) # the following line skips the linter which checks for copyrights # comment the line when a copyright and license is added to all source files set(ament_cmake_copyright_FOUND TRUE) # the following line skips cpplint (only works in a git repo) # comment the line when this package is in a git repo and when # a copyright and license is added to all source files set(ament_cmake_cpplint_FOUND TRUE) ament_lint_auto_find_test_dependencies() endif() # 6. ament工具的功能包整理 ament_package() 利用 colcon 工具构建项目：在项目的工程目录下，输入colcon build进行构建 pldz@pldz-pc:~/share/ROS2_DEMO/1_Chapter/code$ colcon build WARNING: Package name \"vscodeCppDemo\" does not follow the naming conventions. It should start with a lower case letter and only contain lower case letters, digits, underscores, and dashes. Starting &gt;&gt;&gt; vscodeCppDemo --- stderr: vscodeCppDemo WARNING: Package name \"vscodeCppDemo\" does not follow the naming conventions. It should start with a lower case letter and only contain lower case letters, digits, underscores, and dashes. --- Finished &lt;&lt;&lt; vscodeCppDemo [8.27s] Summary: 1 package finished [8.62s] 1 package had stderr output: vscodeCppDemo 执行该项目节点文件： 尝试手动执行，在项目目录下的 build/&lt;ROS2项目名称&gt; 下存放着项目节点 ROS2项目节点，直接运行该文件：如下所示 pldz@pldz-pc:~/share/ROS2_DEMO/1_Chapter/code$ ./build/vscodeCppDemo/vscodeCppDemoNode [INFO] [1682264164.879460585] [helloworld_node]: hello world! pldz@pldz-pc:~/share/ROS2_DEMO/1_Chapter/code$ file ./build/vscodeCppDemo/vscodeCppDemoNode ./build/vscodeCppDemo/vscodeCppDemoNode: ELF 64-bit LSB pie executable, x86-64, version 1 (GNU/Linux), dynamically linked, interpreter /lib64/ld-linux-x86-64.so.2, BuildID[sha1]=53b5061fab0864a3b53f587b0cbc8a6be1d342f1, for GNU/Linux 3.2.0, not stripped 通过ROS2运行节点：首先需要添加项目的install环境，即 source &lt;项目目录&gt;/install/setup.bash，然后可以通过ros2 run &lt;项目名称&gt; &lt;节点名称&gt; 运行节点 pldz@pldz-pc:~/share/ROS2_DEMO/1_Chapter/code$ source ./install/setup.bash pldz@pldz-pc:~/share/ROS2_DEMO/1_Chapter/code$ ros2 run vscodeCppDemo vscodeCppDemoNode [INFO] [1682264459.635230302] [helloworld_node]: hello world! ROS2的C/C++项目的目录结构：在项目目录下输入tree -L 3 查看最多三级文件结构，其中： build文件夹：存储编译的文件和可执行的ROS2节点 install文件夹：直接反应叫安装目录，包括能够通过 ros2 run ... 指令运行ROS2节点的环境 log文件夹：存储日志文件 &lt;项目名的文件夹&gt;：存放ROS2项目的源码，其中的 package.xml配置包信息（包名、版本、作者、依赖项）；CMakeLists.txt 用于配置编译规则（源文件位置，编译所要连接的依赖项等等）； pldz@pldz-pc:~/share/ROS2_DEMO/1_Chapter/code$ tree -L 3 . ├── build │ ├── COLCON_IGNORE │ └── vscodeCppDemo │ ├── ament_cmake_core │ ├── ament_cmake_environment_hooks │ ├── ... 这里手动省略 │ ├── Makefile │ └── vscodeCppDemoNode ├── install │ ├── COLCON_IGNORE │ ├── local_setup.bash │ ├── ... 这里手动省略 │ ├── setup.bash │ └── vscodeCppDemo │ ├── lib │ └── share ├── log │ ├── build_2023-04-23_23-31-44 │ │ ├── events.log │ │ ├── logger_all.log │ │ └── vscodeCppDemo │ └── COLCON_IGNORE └── vscodeCppDemo ├── CMakeLists.txt ├── include │ └── vscodeCppDemo ├── package.xml └── src └── vscodeCppDemoNode.cpp 23 directories, 30 files 1.2.4 使用VSCode创建ROS2的Python项目 创建ROS2的Python项目：ros2 pkg create vscodePythonDemo --build-type ament_python --dependencies rclpy std_msgs --node-name vscodePythonDemoNode，其中依赖项与C/C++的节点不同是rclpy，此时在项目的同名目录下，已经有了节点.py文件 Tips：这里补充还是推荐才有下划线割开的功能包命名方法而不是大小写混合，否则会出错 pldz@pldz-pc:~/share/ROS2_DEMO/1_Chapter/code$ ros2 pkg create vscodePythonDemo --build-type ament_python --dependencies rclpy std_msgs --node-name vscodePythonDemoNode going to create a new package package name: vscodePythonDemo destination directory: /mnt/hgfs/VMware/ROS2_DEMO/1_Chapter/code package format: 3 version: 0.0.0 description: TODO: Package description maintainer: ['pldz &lt;pldz@R7000.com&gt;'] licenses: ['TODO: License declaration'] build type: ament_python dependencies: ['rclpy', 'std_msgs'] node_name: vscodePythonDemoNode creating folder ./vscodePythonDemo creating ./vscodePythonDemo/package.xml creating source folder creating folder ./vscodePythonDemo/vscodePythonDemo creating ./vscodePythonDemo/setup.py creating ./vscodePythonDemo/setup.cfg creating folder ./vscodePythonDemo/resource creating ./vscodePythonDemo/resource/vscodePythonDemo creating ./vscodePythonDemo/vscodePythonDemo/__init__.py creating folder ./vscodePythonDemo/test creating ./vscodePythonDemo/test/test_copyright.py creating ./vscodePythonDemo/test/test_flake8.py creating ./vscodePythonDemo/test/test_pep257.py creating ./vscodePythonDemo/vscodePythonDemo/vscodePythonDemoNode.py [WARNING]: Unknown license 'TODO: License declaration'. This has been set in the package.xml, but no LICENSE file has been created. It is recommended to use one of the ament license identitifers: Apache-2.0 BSL-1.0 BSD-2.0 BSD-2-Clause BSD-3-Clause GPL-3.0-only LGPL-3.0-only MIT MIT-0 pldz@pldz-pc:~/share/ROS2_DEMO/1_Chapter/code$ cd vscodePythonDemo/ pldz@pldz-pc:~/share/ROS2_DEMO/1_Chapter/code/vscodePythonDemo$ tree . . ├── package.xml ├── resource │ └── vscodePythonDemo ├── setup.cfg ├── setup.py ├── test │ ├── test_copyright.py │ ├── test_flake8.py │ └── test_pep257.py └── vscodePythonDemo ├── __init__.py └── vscodePythonDemoNode.py 3 directories, 9 files 创建一个简单的ROS2的Python节点：代码如下，基本内容见注释 import rclpy from rclpy.node import Node # 继承Node类，定义VSCodePythonDemo类 class VSCodePythonDemo(Node): # 初始化Python构造函数 def __init__(self, nodeName:str): super().__init__(nodeName) def printHello(self): self.get_logger().info(\"hello world!\") def main(): rclpy.init() # 创建VSCodePythonDemo对象 node = VSCodePythonDemo(\"vscodePythonDemo\") # 调用成员函数 node.printHello() rclpy.shutdown() Python的VSCode环境配置：默认情况下VSCode的Python解析器，能够定位到rclpy.py的位置在/opt/ros/humble/local/lib/python3.10/dist-packages/下，如果无法找到，可以手动配置.vscode 文件夹下的 settings.json文件，加入\"python.analysis.extraPaths\": [\"/opt/ros/humble/local/lib/python3.10/dist-packages/\"],，这样的配置同样能够将自己安装的的Python依赖项加入到vscode的开发环境中 ROS2的Python项目的简单配置：与C/C++项目不同，Python项目主要配置packages.xml文件来管理依赖项和Python包，setup.py主要给Python项目进行打包配置 packages.xml文件的简单注释： &lt;?xml version=\"1.0\"?&gt; &lt;?xml-model href=\"http://download.ros.org/schema/package_format3.xsd\" schematypens=\"http://www.w3.org/2001/XMLSchema\"?&gt; &lt;package format=\"3\"&gt; &lt;name&gt;vscodePythonDemo&lt;/name&gt; &lt;version&gt;0.0.0&lt;/version&gt; &lt;!-- 包的作者信息,主要来自Git的配置 --&gt; &lt;description&gt;TODO: Package description&lt;/description&gt; &lt;maintainer email=\"pldz@R7000.com\"&gt;pldz&lt;/maintainer&gt; &lt;license&gt;TODO: License declaration&lt;/license&gt; &lt;!-- 编译需要的依赖项,可以手动添加 --&gt; &lt;depend&gt;rclpy&lt;/depend&gt; &lt;depend&gt;std_msgs&lt;/depend&gt; &lt;test_depend&gt;ament_copyright&lt;/test_depend&gt; &lt;test_depend&gt;ament_flake8&lt;/test_depend&gt; &lt;test_depend&gt;ament_pep257&lt;/test_depend&gt; &lt;test_depend&gt;python3-pytest&lt;/test_depend&gt; &lt;export&gt; &lt;build_type&gt;ament_python&lt;/build_type&gt; &lt;/export&gt; &lt;/package&gt; setup.py文件的简单注释： from setuptools import setup # 项目包名 package_name = 'vscodePythonDemo' setup( name=package_name, version='0.0.0', packages=[package_name], data_files=[ ('share/ament_index/resource_index/packages', ['resource/' + package_name]), ('share/' + package_name, ['package.xml']), ], # 依赖的打包工具 install_requires=['setuptools'], zip_safe=True, # 项目用户信息 maintainer='pldz', maintainer_email='pldz@R7000.com', description='TODO: Package description', license='TODO: License declaration', tests_require=['pytest'], entry_points={ 'console_scripts': [ # 可执行文件的入口 'vscodePythonDemoNode = vscodePythonDemo.vscodePythonDemoNode:main' ], }, ) 编译ROS2的Python项目：在项目目录下，输入：colcon build，利用ament_python工具构建Python项目 pldz@pldz-pc:~/share/ROS2_DEMO/1_Chapter/code$ colcon build WARNING: Package name \"vscodeCppDemo\" does not follow the naming conventions. It should start with a lower case letter and only contain lower case letters, digits, underscores, and dashes. WARNING: Package name \"vscodePythonDemo\" does not follow the naming conventions. It should start with a lower case letter and only contain lower case letters, digits, underscores, and dashes. Starting &gt;&gt;&gt; vscodeCppDemo Starting &gt;&gt;&gt; vscodePythonDemo --- stderr: vscodePythonDemo /usr/lib/python3/dist-packages/setuptools/command/install.py:34: SetuptoolsDeprecationWarning: setup.py install is deprecated. Use build and pip and other standards-based tools. warnings.warn( --- Finished &lt;&lt;&lt; vscodePythonDemo [1.41s] Finished &lt;&lt;&lt; vscodeCppDemo [1.79s] Summary: 2 packages finished [2.10s] 1 package had stderr output: vscodePythonDemo 注意此时出现的SetuptoolsDeprecationWarning: setup.py install is deprecated. Use build and pip and other standards-based tools.主要是因为setuptools的版本和ROS2所需要的版本不一致，但是不会影响编译 运行ROS2的Python项目：.py文件本身就是一个可执行的脚本，如果Python解析器的环境依赖都能够被找到的话，可以直接输入python3 xx.py运行文件，同样通过激活./install/setup.bash文件，利用ROS2运行Python节点 pldz@pldz-pc:~/share/ROS2_DEMO/1_Chapter/code$ python3 ./build/vscodePythonDemo/build/lib/vscodePythonDemo/vscodePythonDemoNode.py [INFO] [1682341866.812861345] [helloworld_py_node]: hello world! pldz@pldz-pc:~/share/ROS2_DEMO/1_Chapter/code$ python3 ./vscodePythonDemo/vscodePythonDemo/vscodePythonDemoNode.py [INFO] [1682341890.895240693] [helloworld_py_node]: hello world! pldz@pldz-pc:~/share/ROS2_DEMO/1_Chapter/code$ ros2 run vscodePythonDemo/ --prefix build/ install/ log/ .vscode/ vscodeCppDemo/ vscodePythonDemo/ pldz@pldz-pc:~/share/ROS2_DEMO/1_Chapter/code$ source ./install/setup.bash pldz@pldz-pc:~/share/ROS2_DEMO/1_Chapter/code$ ros2 run vscodePythonDemo --prefix vscodePythonDemoNode pldz@pldz-pc:~/share/ROS2_DEMO/1_Chapter/code$ ros2 run vscodePythonDemo vscodePythonDemoNode [INFO] [1682341946.345360821] [helloworld_py_node]: hello world! pldz@pldz-pc:~/share/ROS2_DEMO/1_Chapter/code$ ROS2的Python项目的简单文件结构：在项目文件夹下输入tree -L 3查看项目三级目录；其中的setup.cfg是功能包基本配置文件，它的作用会影响项目.build文件夹下对Python项目的配置。 pldz@pldz-pc:~/share/ROS2_DEMO/1_Chapter/code$ tree -L 3 . ├── build │ ├── COLCON_IGNORE │ ├── vscodeCppDemo | ... 手动删除了C/C++项目的内容 └── vscodePythonDemo ├── package.xml ├── resource │ └── vscodePythonDemo ├── setup.cfg ├── setup.py ├── test │ ├── test_copyright.py │ ├── test_flake8.py │ └── test_pep257.py └── vscodePythonDemo ├── __init__.py └── vscodePythonDemoNode.py 1.3 ROS2的基本体系 1.3.1 ROS2架构 ROS2的介绍中，有这么一张图，习惯划分说ROS2分为三层来源于B站UP： 操作系统层（OS Layer）：如前所述，ROS虽然称之为机器人操作系统，但实质只是构建机器人应用程序的软件开发工具包，ROS必须依赖于传统意义的操作系统，目前ROS2可以运行在Linux、Windows、Mac或RTOS上。 中间层（Middleware Layer）：主要由数据分发服务DDS与ROS2封装的关于机器人开发的中间件组成。DDS是一种去中心化的数据通讯方式，ROS2还引入了服务质量管理 （Quality of Service）机制，借助该机制可以保证在某些较差网络环境下也可以具备良好的通讯效果。ROS2中间件则主要由客户端库、DDS抽象层与进程内通讯API构成。 应用层（Application Layer）：是指开发者构建的应用程序，在应用程序中是以功能包为核心的，在功能包中可以包含源码、数据定义、接口等内容。 1.3.2 ROS2和ROS1的区别 老生常谈的一个话题了，总结来说： 协议不一样：ROS1用的是TCP和UDP协议，而ROS2用DDS协议；DDS是ROS2的一个很重要的概念，DDS是专用总线协议，速度更快更可靠； 架构不一样，ROS1通过ROS Master管理节点，而ROS2是分布式通讯架构，不需要ROS Master ROS2支持的平台更多，能够支撑嵌入式开发板，实时操作系统RTOS等平台 1.3.3 ROS2应用方向 Nav2项目：Nav2项目继承自ROS Navigation Stack。该项目旨在可以让移动机器人从A点安全的移动到B点。它也可以应用于涉及机器人导航的其他应用，例如跟随动态点。Nav2将用于实现路径规划、运动控制、动态避障和恢复行为等一系列功能 microROS：在基于ROS的机器人应用中，micro-ROS正在弥合性能有限的微控制器和一般处理器之间的差距。micro-ROS在各种嵌入式硬件上运行，使ROS能直接应用于机器人硬件 1.4 总结和参考内容 1.4.1 总结 创建ROS2项目的流程： 创建功能包: ros2 pkg create &lt;项目名&gt; --build-type &lt;cmake/ament_camke/ament_python&gt; --node-name &lt;节点名&gt; --dependencies &lt;rclpy/rclcpp ...&gt; 编辑源文件：采用继承rcl节点发方式，创建ROS2节点 编辑配置文件： C/C++ 配置packages.xml和CMakeLists.txt分别进行依赖项管理和编译配置，Python项目配置packages.xml和setup.py分别进行依赖项和编译安装配置 编译：安装colcon工具，sudo apt install python3-colcon-common-extensions，并且在项目目录下，进行colcon build 执行：激活项目环境source &lt;项目&gt;/install/setup.bash，然后输入ros2 run &lt;package&gt; &lt;node&gt; 1.4.2 参考内容 【ROS2原理3】：构建系统“ament_cmake”和构建工具“ament_tools” ROS2学习笔记（五）– ROS2命令行操作常用指令总结（一） Developing a ROS 2 package C++日志（三十一）类继承时的构造函数 ROS2 API ROS2中文网 ROS2.0整体架构说明 ROS 2 Design"
  },"/ros2_car/2023-01-03-ABOUT.html": {
    "title": "ABOUT",
    "keywords": "ROS2_CAR",
    "url": "/ros2_car/2023-01-03-ABOUT.html",
    "body": "📝 About 持续更新中 📋 Catelog"
  },"/ros2_micro/2023-01-02-ABOUT.html": {
    "title": "ABOUT",
    "keywords": "ROS2_MICRO",
    "url": "/ros2_micro/2023-01-02-ABOUT.html",
    "body": "📝 About 持续更新中 📋 Catelog"
  },"/ros2_basic/2023-01-01-ABOUT.html": {
    "title": "ABOUT",
    "keywords": "ROS2_BASIC",
    "url": "/ros2_basic/2023-01-01-ABOUT.html",
    "body": "📝 About ROS2(humble/foxy)在Ubuntu上的学习笔记 CSDN 入口 📋 Catelog 1 Ubuntu配置与ROS2快速体验 2 ROS2话题通讯 2.1 ROS2话题通讯 - 话题通讯基础 2.2 ROS2话题通讯 - 话题通讯进阶 3 ROS2服务通讯基础 4 ROS2节点参数基础"
  },"/others/2022-01-02-VSCode%E7%9B%B8%E5%85%B3%E9%85%8D%E7%BD%AE.html": {
    "title": "VSCode相关配置",
    "keywords": "Others",
    "url": "/others/2022-01-02-VSCode%E7%9B%B8%E5%85%B3%E9%85%8D%E7%BD%AE.html",
    "body": "editor.stickyScroll.enabled，默认是true，改为false即可"
  },"/others/2022-01-01-ABOUT.html": {
    "title": "ABOUT",
    "keywords": "Others",
    "url": "/others/2022-01-01-ABOUT.html",
    "body": "没有什么可以介绍的"
  }}
